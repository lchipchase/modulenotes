# CS259 Formal Languages

- Intro to the theory of computation
- Automata Theory, Languages, Computation


## What is a language:

An alphabet - a non-empty finite set of symbols:
$\sum_1=\{a,b,c\}$ 

The symbols are arbitrary:

A **language** is a (potentially infinite) set of finite strings over an alphabet

$\sum^*\{$ All finite strings (WORDS) over the alphabet$\sum\}$ 

Sigma star denote

### What do Languages have to do with CS

- Every decision problem can be phrased in the form “is a given string present in the language L”

Does the graph have an independent set of size 100?

- The binary encoding of the given graph present in the language L = \{all binary strings encoding graphs with an IS of size 100\} 

### Deterministic Finite Automation

- Finite set of STATES - L
- Finite set called the ALPHABET - $\Sigma$
- In which state to tart the computation - $q_0\in Q$
- Where are the FINAL/accepting States $F\subseteq Q$
- How to transition from one state  to another: $\delta:Q\cross \Sigma \rightarrow Q$

#### Formal Definition

A machine $M$ defined by the tuple $M=(Q,\Sigma,q_0,F,\delta)$



<img src="C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220111094113420.png" alt="image-20220111094113420" style="zoom:50%;" />

- $q_0$ is the only state that the state can start in, the self accepting states are those with a self loop
- If in q2, no matter what, you return to q2, the same with q3

The additional circle denotes which of the states is a finite state

- Sometimes a machine can be created where it is not possible to reach the final state
- The symbol denotes the direction of the 
- At every state, there must be a result for every given value of the alphabet
  - This is because this is function rather than a partial function

- At the final states add a star
  - In this example, technically all examples could be a final state 

- $\epsilon$ represents the empty string

| Input      | Output |
| ---------- | ------ |
| a          | Accept |
| aa         | Accept |
| abcbc      | Reject |
| bcabc      | Reject |
| $\epsilon$ | Reject |





#### Outcomes

- Create the state transition table for a DFA
- Give an accept or reject for a string
- Give the set of strings that would be accepted
  - In the shown example, any string of length $\leq 1$ consisting only of $a$‘s

DFA, where there is the number of b’s is a multiple of three, regardless of others



### Operations on Regular Languages

![image-20220114160904579](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220114160904579.png)

- Flip the accepting states

![image-20220114160948389](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220114160948389.png)

- Closed under complementation



#### Intersection on regular languages

There exists a DFA for L1 and L2, these are both black boxes. 

- Get the two DFAs together, and only add the common DFAs into the new one?
- Create a DFA which 'pretentds' to be both simultaneuosly

![image-20220114161057999](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220114161057999.png)

Can we build a DFA M3 such that the run of M3 on any string simultaneously simulates the run of both M1 and M2 on the same string

#### Operations on Regular Languages

(**Only works if both languages are over the same alphabet**)

- The alphabets could be different but nonempty instersection

The new transition function must capture this

- Second state is the cartesian product of the initial two
- Every time it reads a symbol, it reads a symbol on both M1 and M2
- For the final accepting state, must be accepted in both
- The transition mimics the transitions in both state machines
- In the new machine, the states appear in pairs

![image-20220114161545474](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220114161545474.png)

##### Applying to a pair of concrete languages

![image-20220114162237897](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220114162237897.png)

- The resulting sates will be pairs:
  - Cartesian product of the two

![image-20220114162405404](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220114162405404.png)

![image-20220114162457454](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220114162457454.png)

- The final result is showsn below, be repeatedly applying the state
- The only accepting stsate is Qa, Qd, as this is the only place where both states are accepcted in the DFa

![image-20220114162659675](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220114162659675.png)

If the intersection is regular, this does not mean that each of the constituent languages are regular.

- L1 = the infinite set of all palindromes with binary strings
- L2 = the set of strings with an even number of 0s

#### The union of regular languages

Assuming that the DFAs are on the same languages



![image-20220114163312269](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220114163312269.png)

- L1 is all binary palindromes
- L2 is all binary strings
  - The intersection of them both is Regular

#### Set Difference

Equivalent to intersection and complementation, which means that they are both regular

-  If L1 and L1\L2 are regular, then L" could also be irregular

![image-20220114163805863](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220114163805863.png)

#### Reversals

If a language L is regular, then the reversal of that language is reguar

- The reversal of the sates and inputs in a DFA, may result in something which is not a DFA

  - An NDA $\downarrow$



### Non Deterministic Finite State Automata - NFA

The same as a DFA, but go to any one of the start states

![image-20220118091156165](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220118091159197.png)



#### Formal Defintition

- Finite set of states: $Q$
- Finite Alphabet $\Sigma$
- Initial State $q_0\in Q$
- Accept States $F\subseteq Q$
- Transition Function $\delta:Q\cross(\Sigma\cup\{\sigma\})\rightarrow 2^Q$
  - This then creates a set of states which is the key difference between that and the 

#### State Transition Diagram

- Previously, there had to be an empty previous state
- Each entry in the table is now a set of states
- Because there are multiple inputs, and sometimes the machine is up to its own 'decision', one route may not be taken with each input each time

![image-20220118091501472](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220118091501472.png)

**Notes**

- DFA has no $sigma$ transitions, and NFA can have $|sigma$ transitions

![image-20220118092252068](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220118092252068.png)

- $\{q_2,q_3\}$
- $\{q_1,q_2\}$
- $\empty$

**Effectively**, q2 could be extended to an accepting state, as this means it can transition to this state either way



#### DFA vs NDA

Each subsequent step is unique.

- NFA statrs in a start state, then creates a copy of itself - one for each state
- Pretends that one took one choice and ignored the rest for each instance
- The goal of an NFA, you have multiple computation path
- Looks for whether any of these lead you to an accepting state
- An abstraction of brute force search
- Every DFA can be considered an NFA

![image-20220118092531939](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220118092531939.png)



#### Extended Transition Function

![image-20220118093126451](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220118093126451.png)

- The $\hat\delta$ represents the fact that, given a 

![image-20220118093137140](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220118093137140.png)

#### Test

![image-20220118093330062](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220118093330062.png)

- $\delta(q_0,a)=\{q_2\}$ - This is the set of all possible ignoring the empty string
- $\hat\delta(q_0,a)=\{q_2,q_0\}$
- $\hat\delta(q_0,b)=\{q_0,q_1,q_2\}$
- $\hat\delta(q_1,b)=\{q_2,q_0\}$





#### $\epsilon$- Closure

$ECLOSE:Q\rightarrow \P(Q)$ 

**Informally** - ECLOSE(Q) denotes all states that can be reached from q by following $\epsilon$ transitions

**Formally**

- $\forall q\in Q,q\in ECLOSE(q)$
- $\forall p,q,\delta \in Q$ if $p\in ECLOSE(q)$ and $r\in delta(p,\epsilon)$ then $r\in ECLOSE(q)$

ECLOSE can be extended to sets of states in the natural way:

![image-20220118094949105](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220118094949105.png)

#### Formally Extended Transition Function

![image-20220118095144126](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220118095144126.png)

#### Language Accepted by an NFA

![image-20220118095504108](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220118095504108.png)

#### Run of an NFA

There can be multiple possible runs

- r0 should always start at q0, 
- There is a way to take the word $S$, and make it into a series $s_i$, where each is either a symbol or the empty string
- If there is $A$ accepting run (even if you need to add multiple empty strings to make this) 

![image-20220120100743451](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220120100743451.png)

A run of M on a word s is called an accepting run if the last sate in this run is an accepting state of M

A word s is said to be accepted by M if some run of M on w is an accepting run. Then the language accepted by the machine M can be defined equivalently

- $L(M)=\{s\in \Sigma^*|$ some run of $M$ on $s$ is an accepting run$\}$ 

#### NFAs for string searching

- Converting the NFA for a DFA that accepts the word chicken
- NFA are not more powerful than DFAs
  - When it comes to the set of languages, if one can accept, then the other can too

![image-20220120103942771](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220120103942771.png)

#### Kruth Morris Pratt string matching algorithm from CLRS

### NFA vs DFA

- There is no such language that is accepted by NFAs, is a strict superset of the class of lanugages accepted by DFAs - regular languages
- Any NFA can be simulated by a DFA

The NFA's state information is captured by a subset of its set of states

- Design a DFA whose extended transition function 'mimics' that of the given NFA

#### Subset Construction

- NFA starts at q0, however, from start input, you can take epsilon transitions to any other state where you can reach in that way
- q1 is a state in the new DFA
- Q1 is equal to the power set of Q0, in order to be able to accommodate every instance of the DFA conversion of the NFA
- The order of ECLOSE() does not matter
  - Where you can reach with only $\epsilon$ transitions
- The set of final states:
  - DFA to accept a word, when looking at the NFA, at least one run ends in a final state
  - If there is a run in the DFA, that finishes on the X
    - For every state in the NFA, there exists a run that stops in X
- Transition Function
  - Small z is a state in the DFA - a set of states in the NFA

![image-20220121161125895](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220121161125895.png)



#### Example

The conversion of NFA to DFA

- Fuzzy text is EClose
- With a,b self loop on the empty set 

![image-20220121164545548](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220121164545548.png)



NFA N=$(Q,\Sigma,q_0,F\delta)$ 

