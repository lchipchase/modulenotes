# CS259 Formal Languages

- Intro to the theory of computation
- Automata Theory, Languages, Computation


## What is a language:

An alphabet - a non-empty finite set of symbols:
$\sum_1=\{a,b,c\}$ 

The symbols are arbitrary:

A **language** is a (potentially infinite) set of finite strings over an alphabet

$\sum^*\{$ All finite strings (WORDS) over the alphabet$\sum\}$ 

Sigma star denote

### What do Languages have to do with CS

- Every decision problem can be phrased in the form “is a given string present in the language L”

Does the graph have an independent set of size 100?

- The binary encoding of the given graph present in the language L = \{all binary strings encoding graphs with an IS of size 100\} 

### Deterministic Finite Automation

- Finite set of STATES - L
- Finite set called the ALPHABET - $\Sigma$
- In which state to tart the computation - $q_0\in Q$
- Where are the FINAL/accepting States $F\subseteq Q$
- How to transition from one state  to another: $\delta:Q\cross \Sigma \rightarrow Q$

#### Formal Definition

A machine $M$ defined by the tuple $M=(Q,\Sigma,q_0,F,\delta)$



<img src="C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220111094113420.png" alt="image-20220111094113420" style="zoom:50%;" />

- $q_0$ is the only state that the state can start in, the self accepting states are those with a self loop
- If in q2, no matter what, you return to q2, the same with q3

The additional circle denotes which of the states is a finite state

- Sometimes a machine can be created where it is not possible to reach the final state
- The symbol denotes the direction of the 
- At every state, there must be a result for every given value of the alphabet
  - This is because this is function rather than a partial function

- At the final states add a star
  - In this example, technically all examples could be a final state 

- $\epsilon$ represents the empty string

| Input      | Output |
| ---------- | ------ |
| a          | Accept |
| aa         | Accept |
| abcbc      | Reject |
| bcabc      | Reject |
| $\epsilon$ | Reject |





#### Outcomes

- Create the state transition table for a DFA
- Give an accept or reject for a string
- Give the set of strings that would be accepted
  - In the shown example, any string of length $\leq 1$ consisting only of $a$‘s

DFA, where there is the number of b’s is a multiple of three, regardless of others



### Operations on Regular Languages

![image-20220114160904579](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220114160904579.png)

- Flip the accepting states

![image-20220114160948389](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220114160948389.png)

- Closed under complementation



#### Intersection on regular languages

There exists a DFA for L1 and L2, these are both black boxes. 

- Get the two DFAs together, and only add the common DFAs into the new one?
- Create a DFA which 'pretentds' to be both simultaneuosly

![image-20220114161057999](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220114161057999.png)

Can we build a DFA M3 such that the run of M3 on any string simultaneously simulates the run of both M1 and M2 on the same string

#### Operations on Regular Languages

(**Only works if both languages are over the same alphabet**)

- The alphabets could be different but nonempty instersection

The new transition function must capture this

- Second state is the cartesian product of the initial two
- Every time it reads a symbol, it reads a symbol on both M1 and M2
- For the final accepting state, must be accepted in both
- The transition mimics the transitions in both state machines
- In the new machine, the states appear in pairs

![image-20220114161545474](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220114161545474.png)

##### Applying to a pair of concrete languages

![image-20220114162237897](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220114162237897.png)

- The resulting sates will be pairs:
  - Cartesian product of the two

![image-20220114162405404](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220114162405404.png)

![image-20220114162457454](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220114162457454.png)

- The final result is showsn below, be repeatedly applying the state
- The only accepting stsate is Qa, Qd, as this is the only place where both states are accepcted in the DFa

![image-20220114162659675](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220114162659675.png)

If the intersection is regular, this does not mean that each of the constituent languages are regular.

- L1 = the infinite set of all palindromes with binary strings
- L2 = the set of strings with an even number of 0s

#### The union of regular languages

Assuming that the DFAs are on the same languages



![image-20220114163312269](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220114163312269.png)

- L1 is all binary palindromes
- L2 is all binary strings
  - The intersection of them both is Regular

#### Set Difference

Equivalent to intersection and complementation, which means that they are both regular

-  If L1 and L1\L2 are regular, then L" could also be irregular

![image-20220114163805863](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220114163805863.png)

#### Reversals

If a language L is regular, then the reversal of that language is reguar

- The reversal of the sates and inputs in a DFA, may result in something which is not a DFA

















































