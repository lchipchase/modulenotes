# CS259 Formal Languages

- Intro to the theory of computation
- Automata Theory, Languages, Computation


## What is a language:

An alphabet - a non-empty finite set of symbols:
$\sum_1=\{a,b,c\}$ 

The symbols are arbitrary:

A **language** is a (potentially infinite) set of finite strings over an alphabet

$\sum^*\{$ All finite strings (WORDS) over the alphabet$\sum\}$ 

Sigma star denote

### What do Languages have to do with CS

- Every decision problem can be phrased in the form “is a given string present in the language L”

Does the graph have an independent set of size 100?

- The binary encoding of the given graph present in the language L = \{all binary strings encoding graphs with an IS of size 100\} 

### Deterministic Finite Automation

- Finite set of STATES - L
- Finite set called the ALPHABET - $\Sigma$
- In which state to tart the computation - $q_0\in Q$
- Where are the FINAL/accepting States $F\subseteq Q$
- How to transition from one state  to another: $\delta:Q\times \Sigma \rightarrow Q$

#### Formal Definition

A machine $M$ defined by the tuple $M=(Q,\Sigma,q_0,F,\delta)$

# 

<img src="C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220111094113420.png" alt="image-20220111094113420" style="zoom:50%;" />

- $q_0$ is the only state that the state can start in, the self accepting states are those with a self loop
- If in q2, no matter what, you return to q2, the same with q3

The additional circle denotes which of the states is a finite state

- Sometimes a machine can be created where it is not possible to reach the final state
- The symbol denotes the direction of the 
- At every state, there must be a result for every given value of the alphabet
  - This is because this is function rather than a partial function

- At the final states add a star
  - In this example, technically all examples could be a final state 

- $\epsilon$ represents the empty string

| Input      | Output |
| ---------- | ------ |
| a          | Accept |
| aa         | Accept |
| abcbc      | Reject |
| bcabc      | Reject |
| $\epsilon$ | Reject |





#### Outcomes

- Create the state transition table for a DFA
- Give an accept or reject for a string
- Give the set of strings that would be accepted
  - In the shown example, any string of length $\leq 1$ consisting only of $a$‘s

DFA, where there is the number of b’s is a multiple of three, regardless of others



### Operations on Regular Languages

![image-20220114160904579](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220114160904579.png)

- Flip the accepting states

![image-20220114160948389](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220114160948389.png)

- Closed under complementation



#### Intersection on regular languages

There exists a DFA for L1 and L2, these are both black boxes. 

- Get the two DFAs together, and only add the common DFAs into the new one?
- Create a DFA which 'pretentds' to be both simultaneuosly

![image-20220114161057999](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220114161057999.png)

Can we build a DFA M3 such that the run of M3 on any string simultaneously simulates the run of both M1 and M2 on the same string

#### Operations on Regular Languages

(**Only works if both languages are over the same alphabet**)

- The alphabets could be different but nonempty instersection

The new transition function must capture this

- Second state is the cartesian product of the initial two
- Every time it reads a symbol, it reads a symbol on both M1 and M2
- For the final accepting state, must be accepted in both
- The transition mimics the transitions in both state machines
- In the new machine, the states appear in pairs

![image-20220114161545474](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220114161545474.png)

##### Applying to a pair of concrete languages

![image-20220114162237897](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220114162237897.png)

- The resulting sates will be pairs:
  - Cartesian product of the two

![image-20220114162405404](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220114162405404.png)

![image-20220114162457454](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220114162457454.png)

- The final result is showsn below, be repeatedly applying the state
- The only accepting stsate is Qa, Qd, as this is the only place where both states are accepcted in the DFa

![image-20220114162659675](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220114162659675.png)

If the intersection is regular, this does not mean that each of the constituent languages are regular.

- L1 = the infinite set of all palindromes with binary strings
- L2 = the set of strings with an even number of 0s

#### The union of regular languages

Assuming that the DFAs are on the same languages



![image-20220114163312269](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220114163312269.png)

- L1 is all binary palindromes
- L2 is all binary strings
  - The intersection of them both is Regular

#### Set Difference

Equivalent to intersection and complementation, which means that they are both regular

-  If L1 and L1\L2 are regular, then L" could also be irregular

![image-20220114163805863](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220114163805863.png)

#### Reversals

If a language L is regular, then the reversal of that language is reguar

- The reversal of the sates and inputs in a DFA, may result in something which is not a DFA

  - An NDA $\downarrow$



### Non Deterministic Finite State Automata - NFA

The same as a DFA, but go to any one of the start states

![image-20220118091156165](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220118091159197.png)



#### Formal Defintition

- Finite set of states: $Q$
- Finite Alphabet $\Sigma$
- Initial State $q_0\in Q$
- Accept States $F\subseteq Q$
- Transition Function $\delta:Q\cross(\Sigma\cup\{\sigma\})\rightarrow 2^Q$
  - This then creates a set of states which is the key difference between that and the 

#### State Transition Diagram

- Previously, there had to be an empty previous state
- Each entry in the table is now a set of states
- Because there are multiple inputs, and sometimes the machine is up to its own 'decision', one route may not be taken with each input each time

![image-20220118091501472](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220118091501472.png)

**Notes**

- DFA has no $sigma$ transitions, and NFA can have $|sigma$ transitions

![image-20220118092252068](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220118092252068.png)

- $\{q_2,q_3\}$
- $\{q_1,q_2\}$
- $\empty$

**Effectively**, q2 could be extended to an accepting state, as this means it can transition to this state either way



#### DFA vs NDA

Each subsequent step is unique.

- NFA statrs in a start state, then creates a copy of itself - one for each state
- Pretends that one took one choice and ignored the rest for each instance
- The goal of an NFA, you have multiple computation path
- Looks for whether any of these lead you to an accepting state
- An abstraction of brute force search
- Every DFA can be considered an NFA

![image-20220118092531939](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220118092531939.png)



#### Extended Transition Function

![image-20220118093126451](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220118093126451.png)

- The $\hat\delta$ represents the fact that, given a 

![image-20220118093137140](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220118093137140.png)

#### Test

![image-20220118093330062](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220118093330062.png)

- $\delta(q_0,a)=\{q_2\}$ - This is the set of all possible ignoring the empty string
- $\hat\delta(q_0,a)=\{q_2,q_0\}$
- $\hat\delta(q_0,b)=\{q_0,q_1,q_2\}$
- $\hat\delta(q_1,b)=\{q_2,q_0\}$





#### $\epsilon$- Closure

$ECLOSE:Q\rightarrow \P(Q)$ 

**Informally** - ECLOSE(Q) denotes all states that can be reached from q by following $\epsilon$ transitions

**Formally**

- $\forall q\in Q,q\in ECLOSE(q)$
- $\forall p,q,\delta \in Q$ if $p\in ECLOSE(q)$ and $r\in delta(p,\epsilon)$ then $r\in ECLOSE(q)$

ECLOSE can be extended to sets of states in the natural way:

![image-20220118094949105](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220118094949105.png)

#### Formally Extended Transition Function

![image-20220118095144126](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220118095144126.png)

#### Language Accepted by an NFA

![image-20220118095504108](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220118095504108.png)

#### Run of an NFA

There can be multiple possible runs

- r0 should always start at q0, 
- There is a way to take the word $S$, and make it into a series $s_i$, where each is either a symbol or the empty string
- If there is $A$ accepting run (even if you need to add multiple empty strings to make this) 

![image-20220120100743451](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220120100743451.png)

A run of M on a word s is called an accepting run if the last sate in this run is an accepting state of M

A word s is said to be accepted by M if some run of M on w is an accepting run. Then the language accepted by the machine M can be defined equivalently

- $L(M)=\{s\in \Sigma^*|$ some run of $M$ on $s$ is an accepting run$\}$ 

#### NFAs for string searching

- Converting the NFA for a DFA that accepts the word chicken
- NFA are not more powerful than DFAs
  - When it comes to the set of languages, if one can accept, then the other can too

![image-20220120103942771](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220120103942771.png)

#### Kruth Morris Pratt string matching algorithm from CLRS

### NFA vs DFA

- There is no such language that is accepted by NFAs, is a strict superset of the class of lanugages accepted by DFAs - regular languages
- Any NFA can be simulated by a DFA

The NFA's state information is captured by a subset of its set of states

- Design a DFA whose extended transition function 'mimics' that of the given NFA

#### Subset Construction

- NFA starts at q0, however, from start input, you can take epsilon transitions to any other state where you can reach in that way
- q1 is a state in the new DFA
- Q1 is equal to the power set of Q0, in order to be able to accommodate every instance of the DFA conversion of the NFA
- The order of ECLOSE() does not matter
  - Where you can reach with only $\epsilon$ transitions
- The set of final states:
  - DFA to accept a word, when looking at the NFA, at least one run ends in a final state
  - If there is a run in the DFA, that finishes on the X
    - For every state in the NFA, there exists a run that stops in X
- Transition Function
  - Small z is a state in the DFA - a set of states in the NFA

![image-20220121161125895](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220121161125895.png)



#### Example

The conversion of NFA to DFA

- Fuzzy text is EClose
- With a,b self loop on the empty set 
- Each  of the states within the new DFA, is a subset of the states within the NFA

<img src="C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS259.assets\image-20220125091108792.png" alt="image-20220125091108792" style="zoom:50%;" />





#### The transition function for a DFA given an NFA



<img src="C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS259.assets\image-20220125090818954.png" alt="image-20220125090818954" style="zoom:50%;" />



#### Subset construction

For every word $s$

- $\hat\delta_1(q_1,s)=\hat\delta(q_0,s)$ 

- proof by induction on $s$

NFA N=$(Q,\Sigma,q_0,F\delta)$ 

#### NFA DFA equivalence

A language is regular iff it is accepted by some DFA and iff it is accepted by some NFA

- $NFA \Leftrightarrow DFA \Leftrightarrow$ Regular languages 



## Regular Expressions

$R=a$ for some $a\in \Sigma$

$R=\epsilon$

$R=\emptyset$

$R=R_1+R_2$ - 

$R=R_1.R_2$

$R=R^*$

### Languages Generated

<img src="C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS259.assets\image-20220125093211205.png" alt="image-20220125093211205" style="zoom:33%;" />

###  Operations

Precedence:

- *, concatenation, +

Let $\Sigma =\{a,b\}$ and $R=(a+b)^*$, then $L(R)=\Sigma^*$ 

A language is accepted by an NFA/DFA iff it is generated by a regular expression

### Regular Expression to NFA

<img src="C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS259.assets\image-20220127101301833.png" alt="image-20220127101301833" style="zoom: 25%;" />

#### Union

Any run which was accepting on either, will now be accepted here

- Also a proof on why they are closed under addition

<img src="C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS259.assets\image-20220127101346068.png" alt="image-20220127101346068" style="zoom: 25%;" />

#### Concatenation

- Chain all accepting states of N1 to the start state of N2, but N1 are no longer accepting

<img src="C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS259.assets\image-20220127101546346.png" alt="image-20220127101546346" style="zoom: 33%;" />

#### Star

- Must accept the empty string no matter what R1 is
- Need to add a new start state because simply keeping the start state of N and making it a final state can result in on accepting runs of N becoming accepting runs, which then renders the eventual construction incorrect

<img src="C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS259.assets\image-20220127102040937.png" alt="image-20220127102040937" style="zoom: 33%;" />



- $L(\emptyset^*)$

### NFA to Regular Expressions

- If a language is accepted by an NFA/DFA it can be represented by a regular expression

#### GNFA

- A generalised NFA is a :

  $(Q,\Sigma, \delta,q_{start},q_{accept})$

  - Q is the finite set of states
  - $\Sigma$ is the input alphabet
  - $\delta:(Q-\set{q_{accept}})\cross(Q-\set{q_{start}})\longrightarrow R$ is the transition function (set of all regex over the alphabet)
  - $q_{start}$ is the start state
  - $q_{accept}$ is the accept state

**In the state diagram**

- $q_0$ is a source and has outgoing transitions to all other states
- $q_1$ is a sink and has in coming transitions from all other states

![image-20220128161340581](C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS259.assets\image-20220128161340581.png)

- For every $q\in Q\backslash\set{q_0,q_1}$
  - $q$ has outgoing transitions to all other states except $q_0$
  - $q$ has outgoing transitions from all other states except $q_f$
  - $q$ has a self transition

- The arcs representing the transitions are labelled with regular expressions over $\Sigma$

  - In this case:

  - $\delta(q_0,q_2) = a^*b$

  - $\delta(q_1,q_1) = a$

  - $\delta(q_1,q_2) = \epsilon$

  - $\delta(q_2,q_1) = a$

    

#### Run

- A run of M on the word s is a seuqnece of states :$r_0,...,r_n$ such that:
  - $r_0=q_0$
  - $\exists$ $ s_1,s_2,...,s_n \in \Sigma^*:s=s_1s_2...s_n\wedge\forall i \in[n], s_i\in L(\delta(r_{i-1},r_i))$

- a run of M on a word is an accepting run if the last state in the run is the accepting state of M

#### Every NFA can be converted to an equivalent GNFA

Strat:

1. Make a new unique final state and add $\epsilon$ transitions from the original final states to the new one
2. Add all possible missing transitions that:
   - Leave a state other than $q_f$
   - Those that enter a state other than $q_0$
3. Label all these transitions with the regex $\emptyset$

#### GNFA to Reg-Ex

Idea:

- iteratively eliminate all states except the start and final states - while preserving the original function

<img src="C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS259.assets\image-20220128162853292.png" alt="image-20220128162853292" style="zoom: 33%;" />



<img src="C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS259.assets\image-20220128162928165.png" alt="image-20220128162928165" style="zoom: 25%;" />

## Irregular Languages

- Let $L=\set{0^n1^n|\geq 0}$

### Using the index of a language to show non -reg

- $\hat\delta:Q\cross\Sigma^*\rightarrow Q$ 
  - $\hat\delta(q,w) = $ the state that the DFA reaches when it starts in q and reads the string w

![image-20220201091122450](C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS259.assets\image-20220201091122450.png)

<img src="C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS259.assets\image-20220201091149712.png" alt="image-20220201091149712" style="zoom:50%;" />

- The DFA does not care whether it reads, cat, rat, or rabbit - only cares what is coming after that
  - No matter what comes after, they will all end up in the same state

1. Define a partition of $\Sigma^*$, showing all strings that take you from $q_0$ to $q_n$ 
   1. This is an equivalence relation, with the number of equivalence classes being the number of states in the DFA

<img src="C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS259.assets\image-20220201091603429.png" alt="image-20220201091603429" style="zoom: 50%;" />



Strings x and y are distinguishable by L if there is a string z such that $x.z\in L$ but $y.z\notin L$ or vice versa

- This relation is defined on the set of all strings and is not relevant to a particular DFA

- Need to produce a certificate to $z$ to show they are different
- Otherwise, the strings are indistinguishable

Indistinguishability is an equivalence relation. $X\equiv_LY$ , whereas, distinguishability is not an equivalence relation.

- The index of $\equiv_L$ is the number of equivalence classes of $\equiv_L$ 
- **If the language is regular if and only if it has a finite index.**
- If the index is infinite, then L must be non-regular, and if L is non-regula

### Using the index of a language to show non-regularity

- To prove L is non-reg, all need to do is:
  - Provide inf set of strings
  - Prove they are pairwise distinguishable by L
- This will prove that they must all lie in distinct equivalence classes of ≡L and so ≡L must have an infinite number of equivalence classes.

#### Example

- 0 - concatenating 1 to this puts it in the language
- 00 - however not for the rest, 11 distinguishes the second from all else, and so on
- 000
- 0000

There are an infinite set of equivalence classes.

#### Example

- $L=\set{1^n|isPrime(n)}$

**Claim**

$1^i$ is indistingishable from $1^j$ for every distinct $i,j$

Assume WLOG that $i<j$

<img src="C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS259.assets\image-20220201093606449.png" alt="image-20220201093606449" style="zoom:33%;" />

- Somewhere along the line, there must be at least one value that is not prime

Let $1\leq k\leq p$ be the first instance

- $p+(k-1)(j-i)$ is prime
- $p+k(j-i)$ is prime

$1^i.1^{[p+(k-1)(j-1)] - i}\in L$

$1^j.1^{[p+(k-1)(j-1)] - i}=1^{p+k(j-1)}=\notin L$

#### Example

$\set{ a^nb^nc^n |n\geq 0}$

- Take $S=L(a^*)$
- $\forall a^i,a^j: i\neq j$
  - $a^ib^ic^i\in L$
  - $a^jb^ic^i\notin L$



## Proving Non-Regularity using Pumping Lemma

Testing if a DFA accepts an infinite language:

- If there is a cycle that is reachable from the start state and which can reach an accpet state in the state diagram of the DFA M, then L(M) is infinite
- Compute the strongly connected components from the graph.
- You need a cycle in the DFA to accept an infinite language. - Must also have a word which is longer than the number of states.

If there is a cycle that is reachable from ths statrt state and which can reach an accept state, in the state diagram of the DFA M, ThenL(M) is inifinite - and vice versa.

<img src="C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS259.assets\image-20220203102207462.png" alt="image-20220203102207462" style="zoom:33%;" />



- If you knock off y, it is still accepted according to the DFA
- But $xy=0^{\alpha + \gamma}1^{p+1}$ 
  - Where $\alpha + \beta + \gamma = p + 1$ and $\beta > 0$
  - $xz \notin L$ 



### The Pumping Lemma

Let L be a regular language. Then there exists a positive integer m such that any $w\in L$ with $|W| \geq m$ can be written as $w=x.y.z$

- $|XY|\leq m$
- $|Y|\geq 1$
- $\forall i \in \set0 \cup \N,x.y^i.z\in L$ 

To prove non-regularity, show that the language violates this property.



**Example**

Let M=$(Q,\Sigma,q_0,F,\delta)$ be a DFA accepting L

- Set $m=|Q|$

<img src="C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS259.assets\image-20220203103432447.png" alt="image-20220203103432447" style="zoom: 50%;" />

<img src="C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS259.assets\image-20220203103457318.png" alt="image-20220203103457318" style="zoom:50%;" />



<img src="C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS259.assets\image-20220203103640646.png" alt="image-20220203103640646" style="zoom: 50%;" />

#### Using It

- Let L be a reg lang, then there EXISTS a postivie int m such that for all $w\in L$ with $|w|\geq m$ there exists a decomposition $W=xyz$ where:

![image-20220203104535696](C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS259.assets\image-20220203104535696.png)

#### The negation

A lang is irregular for all positive itnegers m there exists $aw\in L$ with $|w|\geq m$ such that for all deocmpositions as w=xyz where:

![image-20220203104644442](C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS259.assets\image-20220203104644442.png)

#### proof Structure

1. Suppose L is regular and let m be the pumping length of L
2. Choose a string $w\in L$ such that $|w|\geq m$
3. Let w=xyz be an arbitrary decomposition of w such that $|xy|\leq m,|y|>0$
4. Carefully pick an int $i$ and argue that $xy^iz\notin L$

Contradicts the pumping lemma.

#### Example - Prime

<img src="C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS259.assets\image-20220203105253717.png" alt="image-20220203105253717" style="zoom:33%;" />

<img src="C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS259.assets\image-20220203105404558.png" alt="image-20220203105404558" style="zoom:33%;" />

### Using pumping lemma to show a languag is non -regular

- $L=\set{w\in\set{a,b}*|n_a(w)<n_b(w)}$ 
  1. Suppose L is regular and let m be the pumping length of L
  2. Choose a string w\in L such that |w| >= m
  3. LEt w =xyz be an arbitrary decompodition of w such that |xy| <= m, |y| > 0
  4. Pick an int i

1. M denote the lenth of L
2. Choose $W=a^mb^{m+1}$ 
3. $x=a^\alpha,y=a^\beta,z=a^\gamma b^{m+1}$
4. $i = 2$



![image-20220204161242410](C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS259.assets\image-20220204161242410.png) 





### Example in Exam

Write down phone image

## Proving Irregularity using closure properties

<img src="C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS259.assets\image-20220204161705853.png" alt="image-20220204161705853" style="zoom:33%;" />



### Pumping Lemma Problem

- This cannot be used to prove a language is regular

<img src="C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS259.assets\image-20220204162133044.png" alt="image-20220204162133044" style="zoom:33%;" />

- L is not regular
- Satisfies the conditions of the pumping lemma
- L3 = $\set{ab^pc^q|p,q\>0}$ 

If L is regular, then $L\cap L_3$ must be regular

- THe intersection implies that $p=q$ which means that this language is irregular



**L satisfies the pumping lemma**

Proof: Let m=1. Pick any string w ∈ L of length at least 1. Claim 2: L satisfies the pumping lemma. If w∈ L2 ,then pick any decomposition x.y.z=w satisfying the length constraints. Notice that for any i>=0, x.yi .z is also in L2 and hence in L.

If w∈ L1 then w = a t b k c k . Let us take w=x.y.z, where x= $\varepsilon$, y= a, and z = a t-1b k c k For any i>0, x. yi .z = a t-1+i b k c k is also in L1 and hence in L. L1 = { at b k c k |t,k > 0 } L2 = {b,c}* For i=0, x. yi .z = a t-1 b k c k is in L1 if t>1 and it is in L2 if t=1. In either case, x. y i .z is in L as required





### Languages are not closed under the infinite union/intersection of regular languages

$\Sigma^*\backslash L=\set{s,....}$ - where L is non - regular



## Grammars:

<img src="C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS259.assets\image-20220210100736065.png" alt="image-20220210100736065" style="zoom: 25%;" />

<img src="C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS259.assets\image-20220210100828160.png" alt="image-20220210100828160" style="zoom:25%;" />

 





### Language of a Grammar

L(G)= $\set{w\in \Sigma^* | S\Rightarrow^* w }$

- all strings in Σ* which can be derived from S using finitely many applications of the production rules in G

### Left/Rightmost derivations

- You can use left or right derivations, and either can be used ofr all words in the language



### Parse Trees

- The tree generated by applying the rules in the language

<img src="C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS259.assets\image-20220210101116896.png" alt="image-20220210101116896" style="zoom:25%;" />

#### Ambiguity

- Some are ambiguous
- Some can be converted to be unamibuous



A grammar G is ambiguous if and only if the same string can be derived with two left-most derivations

- These are then inhenrently ambiguous languages

![image-20220210101243828](C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS259.assets\image-20220210101243828.png)

# DFA to Grammars

## DFA to (Strictly Right-Linear) Grammars

<img src="C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS259.assets\image-20220210101315718.png" alt="image-20220210101315718" style="zoom:25%;" />

- ALl strings that will take me to some accept state if I start from S
- All strings that will take me to some accept state if I start from y
- All strings that will take me to some accept state if I start from x

**For this DFA**

- $S\rightarrow b.S|a.X|\varepsilon$
  - $b$ folled by any string that will take me FROM s to a final state
  - Or a followed by a ny string that will take me FROM x to a final state
- $X\rightarrow b.S|a.Y$
- $Y\rightarrow b.Y|a.Y$ 

If you hit $Y$, then in a finite number of steps, you will never make a real string. Leaving you with the right linear grammar:

- $S\rightarrow b.S|a.X|\varepsilon$
- $X\rightarrow b.S$

**Formally**

<img src="C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS259.assets\image-20220210102019961.png" alt="image-20220210102019961" style="zoom:25%;" />

## Claim

- $\forall s\in \Sigma^*,q\in Q, \hat\delta(q,s)\in F, iff, q\Rightarrow^*s$

## Example for this DFA



![image-20220210102256185](C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS259.assets\image-20220210102256185.png)

- $A\rightarrow 1.B|0.E$ 
- $B\rightarrow 1.E|0.C$
- $C\rightarrow 1.D|0.A$
- $D\rightarrow 0.D|1.D$
- $E\rightarrow 0.D|1.D|\varepsilon$

For the actual language, remove all states which go to $D$

## DFA to Strictly Left Linear Grammars

- You want all strings that take you to A FROM the start state

<img src="C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS259.assets\image-20220210102705535.png" alt="image-20220210102705535" style="zoom:33%;" />

- $A\rightarrow \varepsilon |C.0$
- $B\rightarrow A.1$
- $C\rightarrow B.0$
- $D\rightarrow$ -Nothing for $D$
- $E\rightarrow B.1|A.0$

### For multiple accept states

- Adding a new accept state which is led to by the accept states

![image-20220210103042637](C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS259.assets\image-20220210103042637.png)

$R;$ add $q_0\rightarrow \varepsilon$

- $\forall q,q'\in G,a\in \Sigma$ if $\delta(q,a) =q'$ then add rule $q'\rightarrow qa$
- $\forall q\in F$ add rule: $q^*\rightarrow q$



### NFA to strictly, left/right linear grammars

- Same works for an NFA

# Context Free Languages

- How many context free grammars could you write
- Countably infinite grammars
- Uncountably infinite grammars

- Any grammar can only generate one language

**Closure Properties**

## A machine for a CFL

- $L=\set{0^n|1^n|n\geq0}$

Take a DFA and equip a counter

- $L=\{$ set of balanced parantheses$\}$
  - $R:S\rightarrow (S)|SS|\varepsilon$



<img src="C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS259.assets\image-20220210104826016.png" alt="image-20220210104826016" style="zoom:33%;" />







- $L=\{w\#w^R\}$
  - $R:S\rightarrow 0S0|1S1|\#$ 



<img src="C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS259.assets\image-20220210105013068.png" alt="image-20220210105013068" style="zoom:33%;" />







## Memory  for the machine

- Use a stack
- Finite Automaton + a STACK = Push Down Automaton/ Push Down Machine
- LIFO structure



## Formal MAchine

- a 6 tuple $(Q,\Sigma,\Gamma,\delta,q^0,F)$ where $Q,\Sigma,\Gamma,F$ are all finite sets
  - $Q$ is the set of states
  - $\Sigma$ is the input alphabet
  - $\Gamma$ is the stack alphabet, includes $\Sigma$ and unusally $\$$ which is the empty stack word
  - $\delta;Q\cross\Sigma_\varepsilon \cross\Gamma_\varepsilon \longrightarrow\P(Q\cross \Gamma_{\varepsilon})$
  - $q_0\in Q$ is the start state
  - $F\subseteq Q$ are the set of accept states 



## Transitions in PMDs

![image-20220210105604297](C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS259.assets\image-20220210105604297.png)



<img src="C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS259.assets\image-20220217101503919.png" alt="image-20220217101503919" style="zoom:25%;" />



**Just push $\$$ and move**

- $\varepsilon,\varepsilon\rightarrow \$$  - usually start with this transition
- $\varepsilon ,\$\rightarrow \varepsilon$ - usually end with this transition to empty the stack
- $\varepsilon ,\varepsilon \rightarrow \varepsilon $ - just move
- $\varepsilon ,\varepsilon \rightarrow b$ - just push $b$ and move
- $a,\varepsilon \rightarrow b$ - read a, push b and move
- $a,c\rightarrow b$ - read a, pop c push b and move
- $\varepsilon ,c\rightarrow b$ pop c, psh b and move
- $a,c\rightarrow \varepsilon $ read a, pop c, and move
- $a,\varepsilon \rightarrow \varepsilon $ read a and move

### PDA for $L=\set{0^n1^n|n\geq 0}$

<img src="C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS259.assets\image-20220217102212886.png" alt="image-20220217102212886" style="zoom:25%;" />







### PDA for $L=\set{w\#w^R}$ where $w$ is over $\set{0,1}$ and $\#$ is not in $\set{0,1}$

<img src="C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS259.assets\image-20220217102418813.png" alt="image-20220217102418813" style="zoom:25%;" />

















## Non -deterministic algorithm to calculate the left-most derivation of a string

1. Set currentString:=S where S is the start variable
2. do:
   1. If the left most element of a currentString is a variable A, then non-deterministically select one of the grammar rules for A and replace the left most A in currentString with the string on the RHS of the rule. Keep a record of the grammar rule application
   2. If the left most variable of currentString is a terminal a, then read a next symbol and check if it is the same as A, If so, then  remove the lfet most elelennt of currentString and repeat. Else, terminate the branch of the algorithm.
   3. If currentString is empty, then we have completed the derivation and so output the recorded grammar rules in reverse order and stop.

## Algorithm to check if a left most derivation of a string exists

1. Push $\$S$ on to the stack, where $S$ is a start variable
2. do:
   1. If the top of the stack is a variable A, then non-deterministically select one of the grammar rules for A, pop A and push the string on the rhs of the rule
   2. If the top of the stack is a terminal a, then read the next input symbol and check if it is the same as a. If so, then pop the top of the stack. Else, reject on this ‘branch’ of the PDA.
   3. If the stop of the stack is $\$$ then exit

## CFG $\rightarrow$ PDA

Construction of PDA from a CFG

- Start state $q_s$
- Loop state $q_l$
- Accept state $q_a$

Implicitly use a number of auxiliary states whenever

<img src="C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS259.assets\image-20220213151705807.png" alt="image-20220213151705807" style="zoom:33%;" />

### Example:

$L=\set{0^n1^n|n\geq 0}$

<img src="C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS259.assets\image-20220213152156887.png" alt="image-20220213152156887" style="zoom:25%;" />

<img src="C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS259.assets\image-20220213152214291.png" alt="image-20220213152214291" style="zoom:25%;" />

- $\varepsilon,\varepsilon \rightarrow \$S$ 
- $\varepsilon S \rightarrow \varepsilon $
- $0,0 \rightarrow \varepsilon$
- $1,1 \rightarrow \varepsilon$ 

**Running on input 000111 gives the execution of:**

<img src="C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS259.assets\image-20220213153007125.png" alt="image-20220213153007125" style="zoom: 33%;" />

## PDA $\rightarrow$ normalised PDA $\rightarrow$ CFL

### Normalised PDA

1. It has a single accept state $q_{accept}$ 
2. It empties its stack before accepting

<img src="C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS259.assets\image-20220217103447008.png" alt="image-20220217103447008" style="zoom:33%;" />

3. Each transition either pushes a symbol onto the stack 9a push move), or pops one off the stack (a pop move), but not both at the same time
   1. Add an intermediate state, which pushes in one step and pops in the other
   2. If there is nothing on there, push and pop an arbitrary thing

### Normalised PDA $\rightarrow $ CFG

<img src="C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS259.assets\image-20220217103934743.png" alt="image-20220217103934743" style="zoom:33%;" />

- There is a non terminal $A_{pq}$ for each pair of states pa dn q
- This generates all strings which take us from state p with empty stack to state q with empty stack
- A=Language accepted by the PDA is the set of strings which can be dreived from the non-terminal A__{q-initial q-final}_ 



#### Rule 1

<img src="C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS259.assets\image-20220217104314013.png" alt="image-20220217104314013" style="zoom:33%;" />

<img src="C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS259.assets\image-20220217104330121.png" alt="image-20220217104330121" style="zoom:25%;" />

- The new rule, will take you to s, with just u left in the stack
- This u is essentially left unaffected,
- Then allowing for a legal transition fro s to q

- u cannot be the emtpy string, because the PDA is normalised, therefore, in the first transition, this must push something and remove something each time.























 

 

 

 

 

 

 

 

 

 

 

 



 





 

 

 

 

 

 

 

 

 

 

 

 



 





 

 

 

 

 

 

 

 

 

 

 

 



 





 

 

 

 

 

 

 

 

 

 

 

 



 





 

 

 

 

 

 

 

 

 

 

 

 



 





 

 

 

 

 

 

 

 

 

 

 

 



 





 

 

 

 

 

 

 

 

 

 

 

 



 





 

 

 

 

 

 

 

 

 

 

 

 



 





 

 

 

 

 

 

 

 

 

 

 

 



 





 

 

 

 

 

 

 

 

 

 

 

 



 





 

 

 

 

 

 

 

 

 

 

 

 



 





 

 

 

 

 

 

 

 

 

 

 

 



 





 

 

 

 

 

 

 

 

 

 

 

 



 





 

 

 

 

 

 

 

 

 

 

 

 



 





 

 

 

 

 

 

 

 

 

 

 

 



 





 

 

 

 

 

 

 

 

 

 

 

 



 





 

 

 

 

 

 

 

 

 

 

 

 



 





 

 

 

 

 

 

 

 

 

 

 

 



 





 

 

 

 

 

 

 

 

 

 

 

 



 





 

 

 

 

 

 

 

 

 

 

 

 



 





 

 

 

 

 

 

 

 

 

 

 

 



 



























































































































































