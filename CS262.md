# CS262 Logic And Verification

# What is logic

- Study of correct reasoning
- Mathematical logic - captures reasoning in a fully formal system
- Four pillars of logic:
  - Set theory
  - Model theory
  - Proof theory
  - Recursion theory

## Politicians fallacy

- Improve things, changes must be made
- Policy is to change things
- Therefore improving things

## Induction and Recursion

**Induction**

- Build a bigger structure from its constituents /technique

**Example**

- Variables x,y,z
- sums/product of terms

**Theorem**

- Number of opening parenthesis = number of closing

Recursion - Decompose a bigger structure into its constituents / programming technique

```
f(x) = 0
f((X+Y)) = f(X) + f(Y) + 2
f((X*Y)) = f(X) + f(Y) + 2
```

## Syntax and Semantics



**Syntax**

- Formal specification of a language - often by induction

**Example**

- Arithmetic
  - $1,s(1),s(s(1)),+/\cross$

**Semantics**

- Meaning of the formal symbols in a particular context
  - Domain of variables/quantifiers (natural numbers)
  - Formal language needs interpretation in a particular model
  - Truth/falseness depends on the model

The combination of the two concepts gives full meaning and definition to a language, which then can be used if statements given are true or false

# Lecture 2 - Basics of prop logic

A formal system for reasoning about propositions

- Proposition = Formula = Statement

## Atomic vs compound propositions

Atomic:

- The simplest possible proposition, and cannot be broken down

Compound:

- Propositions joined by other words

It is the form of the argument that matters rather than the meaning of the sentences

- The words if it is raining, or if I get full marks are arbitrary

## Propositional Language

Atomic formulas - the most basic propositions

$p=$ it is raining

Logical connectives/operators allow the building of more complicated propositions

- $¬$ negation - it is not raining
- $\wedge$ and it is raining and I take my umbrella
- $\or$ or It is raining or i take my umbrella
- $\rightarrow$ implies If it is raining then I take my umbrella

$\circ\in\{\and,\or,\rightarrow,..\}$

## Syntax of propositional formulas

**Prop formulas**

- Are exactly those that can be constructed by a finite number of applications of the following rules
  - Propositional variables, p,q,r and $\top$ and $\bot$ are atomic formulas
  - If $X$ is a formula, so is $¬X$
  - If $X,Y$ are formulas then so is $(X\circ Y)$ where $\circ$ is any binary connective

**Conventions**

May leave out brackets where there is no ambiguity

## Parse Tree

![image-20220112111751753](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220112111751753.png)

- A recursive definition of a subtree

- There is a distinction between left and right child,
  - With binary connectives, such as implication

### Induction and Recursion

- We can define recursive functions on formulas

![image-20220112111947438](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220112111947438.png)

- Where deg(A) = 0 is the base case of the formula
- The negation adds 1
- The combination, adds 1, then the degrees of the two sub formulas

#### **Theorem**

- The degree of a formula equals the number of inner nodes of the parse tree

**Proof**

A proof of induction over the structures

- typically over numbers, however works on any inductively defined stucture

**Base Case**

Atomic Formula: $x$

- These are leaves in the parse tree
- Contribute nothing (0) to the number of inner nodes

$deg(x)$ = 0

**Induction Step:**

- There are two ways of defining propositional formulas:
  - Negation
  - Binary connective

1. $¬$

- Having a negation, means that there is a variable or a formula being negated, hence this increases the number of inner nodes:
- $deg(¬x)=deg(x)+1$, - The degree of $¬X$ = $deg(X)+1$

2. $\circ$ 

There is a subtree with binary connectives:

- $deg(X\circ Y) = 1+deg(X)+deg(Y)$

- This means that $\circ$ is an inner node, which generates the plus one:
  - Since the number of inner nodes of each are the same, then the proof is concluded:

$\square$

## Semantics of Propositional Logic

![image-20220112113505902](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220112113505902.png)

- T,F or 0,1

### Truth table connectives

![image-20220112113739849](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220112113739849.png)

The nullary connectives are what always gives you true or false

$X\rightarrow Y$

- The first is the premise, and the second the conclusion

- $\downarrow$ - nand
- $\uparrow$ - nor



### Valuations

This is a mapping V from the set of propositional formulas to the set of truth values $\{T,F\}$ satisfying the conditions:

![image-20220112114542917](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220112114542917.png)

- To examine all interesting valuations for a given formula, it is enough to specify v for each varible. The value of all sub formulas can be deduced bottom up (in the parse tree)

- A truth table specifies all valuations

### Tautologies, contradictions

- A formula evaluates to $T$ under all valuations is called a tautology
- A formula that evaluates to $F$ under all valuations is called a contradiction
- A formula that evaluates to $T$ for some is called satisfiable



## Complete Set of Connectives

- Said to be complete if we can represent every truth function: $\{T,F\}\rightarrow\{T,F\}$ using only these connectives
  - $2^{2^n}$ such functions

| p     | f1   | f2   | f3   | f4   |
| ----- | ---- | ---- | ---- | ---- |
| **T** | T    | T    | F    | F    |
| **F** | T    | F    | T    | F    |

- f1 = T
- f2 = $p$
- f3  = $¬p$
- f4 = $\bot$ 

### Proof By Construction

To create a formula that is given is logically equivalent to any function $f$ on variables $x_1,...,x_n$ given by its truth table.

![image-20220118131810143](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220118131810143.png)

- This is the disjunctive normal form of f

- A  formula in DNF is a disjunction of conjunctions of literals. A literal is a variable or its negation or $\top,\bot$
- A formula in CNF is a conjunction of disjunctions of literals

### Normal Form Algorithms

- Deriving DNF or CNF in systematic ways

### Generalized Disjunctions/conjunctions

Let $X_1,...,X_n$ be a sequence of propositional formulas

Generalised disjunction as:

- $[X_1,...,X_n] = X_1\or ...\or X_n$ - associativity

Generalised Conjunction as

-  $\langle X_1,...,X_n\rangle=X_1\and...\and X_n$

If these variables are literals, then $[X_1,...,X_n]$ is a clause, else it is a dual clause

**Literal** is a variable, its negation or a nullary operator 

### Valuations on generalised disjunctions

![image-20220118134910248](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220118134910248.png)

### $\alpha \beta $ formulas

- All proposotional formulas of the forms $(X\circ Y)$ and $¬(X\circ Y)$ where $\circ$ is one of the binary connectives intwo two categories, those that act conjunctively and those that act disjunctively

![image-20220119111150121](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220119111150121.png)



![image-20220119112315346](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220119112315346.png)



### CJNF Algorithm

- Given any propositional formula, start take X, and create a conjunction of disjunctions $\langle[X]\rangle$
- Look somewhere inside for the square brackets

![image-20220119112402718](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220119112402718.png)



#### Compact Form

- Top row is what we have, bottom is what we do

![`](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220119115100801.png)

#### Proof of Correctness

The algorithm produces a sequence of logically equivalent formula

![image-20220119115327950](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220119115327950.png)

#### Termination of the Algorithm

- The algorithm terminates regardless of which choices are made during the algorithm

- Consider a rooted tree. A branch is a sequence of nodes starting at the root, descending towards one of the children in each step (unless no children are present). We say that the tree is finitely branching, if every node has only finitely many children (possibly 0). A tree/branch is finite if it has a finite number of nodes; otherwise it is infinite.

**A tree that is finitely branching, but infinite, must have an infinite branch**

##### A game with balls

Consider the following game played with balls that have non negative integer values

- At the beginning, have a box with just one ball
- At the beginning, we have a box containing just one vall
- In each step, we can remove one ball from the box, and replace it by any finite number of balls having lower numbers

The game must end, regardless of which choices are made during the game

To prove the termination of the algorithm, define a rank of the propositional formulas as follows:

Recursion anchor: $r(p)=r(¬p)=0$ for all variables $p:r(\top)=r(\bot)=0$

- $r(¬\top)=r(¬\bot)=1$

Recursive Step: $r(¬¬Z)=r(Z)+1$

$r(\alpha)=r(\alpha_1)+r(\alpha_2) + 1;r(\beta)=r(\beta_1)+r(\beta_2)+1$

![image-20220120163826343](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220120163826343.png)

![image-20220120164604563](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220120164604563.png)

![image-20220120165430102](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220120165430102.png)

# Semantic Tableau and Resolution

- Two proof procedures for propositional logic, emantic tableu and resolution

Semantic tableau: closely connected to disjunctive normal form

Resolution - closely connected to conjunctive normal form

Both systems well suited for  automation

- Assignment, implement a resolution theoram prover in Prolog

Both are refutation systems: to prove a formula X is a tautology, begin with ¬X and form a contradiction

## Semantic Tableau

Proof takes form of a tree, with nodes labelled by propositional formulas

![image-20220125132200230](C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS262.assets\image-20220125132200230.png) 

Each branch as a conjunction of the formulas on that branch, and the tree as the disjunction of all of its branches - DNF

### Tableau Expression

In each step, select a branch and a non literal formula N on that branch

- If $N=¬\top$, then extend the branch by a node labelled $\bot$ at its end
- If $N=¬\bot$ then extend the branch by a node labelled $\top$ at its end
- If $N=¬¬Z$ then extend the branch by a node labelled $Z$ at its end

- If $N$ is an $\alpha$ formula, then extend the branch by two nodes labelled $\alpha_1,\alpha_2$ ($\alpha$ expansion)
- If $N$ is a $\beta$ formulaa, then add a left and right child to the final node of the branch, and label one of them $\beta_1$ and the other $\beta_2$ - $\beta$ expansion

![image-20220125133501912](C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS262.assets\image-20220125133501912.png)



### Closed Tableau

A branch of a tableau is closed, if both X and ¬X occur on the branch for some formula X or if $\bot$ occurs on the branch

If x and ¬x appear on a branch where x is a variable, or if $\bot$ appears, then the branch is automatically closed

A tableau is (atomically) closed, if every branch is (atomically) closed

A tableau proof of X is a closed tableau for $¬X$

Write $\vdash_t X$ if X has a tableau proof 







### Tableau Properties

- Can be very short compared to truth tables.

  - $X\or ¬X$ for a complicated formula X
  - This instantly creates a negation
  - Extends to first order logic - quantifiers
  - Tableau can be generalised to establish propositional consequences $S\models X$, not just Tautologies $\models X$

  - The rules are non-deterministic

### Implementation

- Reuse of formulas, how do we know when to give up on a proof attempt. Try again something we have tried before - they don't prohibit expansion twice
- A tableau is strict if no formula has had an expansion rule applied to it on the **same branch**
- Represent the tree as a list of lists - disjunction of conjunctions: Strictness rule allows us to remove an expanded formula from the list
- Could run DNS expansion algorithm and check for closure in the end
  - Every branch is a conjunction of literals - in CNF - possibly less efficient
- Do not need to expand completely before checking for closure
- Proof can be shortened to effectively check the expansion rule
- Considerable necessity for heuristics

### Theorem:

The tableau proof system is sound:

- If X has a tableau proof, then X is a tautology

The tableau proof system is complete:

- If X is a tautology, then the strict tableau system will terminate with a proof for it

First theorem follows from the correctness proof of our DNF expansion algorithm given before: Every expansion step produces a logically equivalent formula

















































































