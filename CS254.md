# CS254 Algorithmic Graph Theory

## Week 1 - lecture 1



Key points

- understanding basic properties of graphics and design efficient algorithms
- Designing efficient algorithms for graph problems
- Analysing algorithms and proving correctness

Motivated typically by IT/CS

Running and correctness to determine the quality of the algorithms

### Introduction

#### Basic definitions

Graph definitions (according to module)

Graph:

- A pair of vertices and edges $G=(V,E)$
  - V are vertices / nodes
  - E are pairwise relations of elements of V
- Undir graph $G=(V,E)$  (typically this is the type which will be looked at)
  - V are vertices
  - E are edges - a set of sets of pairs of edges
- di Graphs - simple
  - V a set of vertices
  - $E\subseteq V \cross V$ edges, where E is non - reflexive
- Undir multigraph - pseudograph
  - A set of V vertices
  - A multi set E of edges that consist of two-element multi-sets over elements V
- Directed multigraph
  - The same as a digraph, but allows multiple elements
  - $E\subseteq V\cross V$ -
    - Terminology - sometimes an edge is an arc
- Order of a graph
  - The cardinality of the vertex set, usually use $n$ to denote $|V|$
- The size of a graph is the cardinality $|E$| of its edge set
- A graph that does not contain , multi edges or self loop is called simple

- An edge $e$ is incident to a vertex $v$ if:
  - $v\in e$ for undirected graphs
  - $e=(v,x)$ or $e-(v,x)$ with $x\in V$ 
- The two vertices an edge e is incident to are called the end points of e
- Two vertices u and v are adjacent if there is an edge e that is inciden to both of them
- Two edges are called adjacent if they share some commone vertex
- For a digraph, $u$ is called the tail and v s called the head
- The degree is the number of edges incident to it
  - Self loop is counted twice
- Inand out degreee in a digraph
- $deg(vv) = indeg(v) + outdeg(v)$
- $\sum_{v\in V} deg(v)=2E$

- $\Delta$ is denoted for the maximum degree of a graph
- A sequence is called a path if:
  - $\forall i \in \{1,…,k-1\}:\{v_j, v_{i + 1}\}\in E$
- The length is the number of its edges
- A path is called a cycle if it has the same start and end point
- Is simple if al; vertices are distinct
- A cycle is simple if the vertices are distinct  - bar the start and finish
- A cycle of odd(even) length is called an odd(even) cycle

Graph connection

- Call a undir graph G connected if there exists a u,v path for ever pair of vertices u and v
- We call a digraph G connected if for ever pair for vertices u,v there exists either a u v path or a  v u path
- Call a digraph strongly connected if for every pair of vertices u,v there exists a u,v path and a v, u path

Subgraph terminology

- A subgraph if the edges and nodes are a subset of the original graphs
- Induced subgraph of $G$ if it is a subgraph of $G$ and $E’$ contains all edges of $E$ with end points in $V’$ 
- A subgraph of $G’=(V’,E)$ of a graph $G=(V,E)$ is called spanning if $V’ = V$

- undir graph that does not contain a cycle as a subgraph is a forest
- An undir graph, connected graph that does not contain a cycle as a subgraph is called a tree
- A spanning subgraph of a graph $G$ that is a tree called a spanning tree of $G$

DAG

- a directed graph that does not contain a cycle is called a DAG
- Has a maximum of $\frac{n(n-1)}{2}$ 
- $V=\{1,…,n\}$
- $E=\{(i,j), i <j\}$

Bipartite graphs

- An undir graph $G=(V,E)$ is called bipartite if the set $V$ can be decomposed into subset $V_1,V_2$ such that
- $V=V_1\uplus V_2$

### Testing Bipartiteness

Is there a partition of $V$ into two set $V_1$ and $V_2$ such that $V_1,V_2$ are independent sets

- WLOG add the first node into $V_1$ 

Use a two colouring 

- The second must be in $V_1$

#### Corollary

A graph that contains an odd cycle is not bipartite

- A graph is not bipartite iff G contains an odd cycle



### BFS and Bipartiteness

P1 - Edges not contains in the BFS tree can only connect successive layers or may connect nodes on the same layer

P2 - The BFS tree contains a shortest (s,v) path for every node v reachable from s

- Run  BFS and analyse the structure of the explored graphs
- Consider only connected graphs

**Lemma**

G is bipartite iff there is no edge u,v with u and v on the same level in the BFS tree

A graph is bipartite iff it does not contain an odd length cycle

**P2 Shortest path property**

- The nodes are added to the BFS tree in non-decreasing order of distance to s

![image-20220117132235873](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220117132235873.png)



- By the prooof above, we know that nodes are added to T in non-decreasing order
- Proof by cont:
  - Assume that v is the node closest to s in G for which no shortes s,v path is contained in T]
- Let u denote the predecessor of v in some shortes s,v path and let x denote the predecessor of v in T
- Then some shortest s,u path will be contained in 

![image-20220118160925868](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220118160925868.png)

**P1 Proof**

- $\{u,v\}\in E$ so that u is on layer l, v is at layer l'. $l<l' - 1$
- $dist(s,v) = l' - 1, dist(s,u) = l$
  - $l + 1 \geq l'$
  - Contradiction

## Graph Representation

- BFS algorithm runs in time $O(n+m)$ to determine if an undirected graph is bi partite, if the graph is represented by adjacency lists

### Adjacency list advantages

- Go thorugh all vertices in $O(n)$ time
- For every vertex $v$ we can go through all neighbours of $v$ time $O(d(v))$
- Checking if $(u,v)\in E$ requires $\Theta(min\{d(v),d(u)\})$
- Topological sort can be done in O(m+n)

### Adjacency Matrix Advantages

- Go through all list of vertices in $O(n)$
- Checking if an edge, can take $O(1)$ time



### Problem

- Simple digraph $G=(V,e)$ a vertex $u\in V$ is a sink if:
  - In $deg(u)=n-1$
  - out $deg(u)=0$
- Given a simple digraph $G=(V,e)$ one can find all its sinks in time $O(n)$

**Claim** no simple digraph has more than one sink

Suppose G has two or more sinks

- Let $u,v\in V$ be two sinks
- Since u is a sink, $indeg(u)=n-1$ and $outdeg(u) = 0$
- Means that $(u,v)\notin E$

**Algorithm**

Check u,v $\in E$

- This will tell us that there is at least one of $u,v$ is not the sink
- If $uv \in E$ then u is not a sink, 
- If $u,v \notin E$ then v is not a sink,
- After $n-1$ tests, there will be only one vertex surviving.
  - Cannot know if it is a sink
  - Check every vertex $v\in V$
    - $(u,v)\notin E$ and $(v,u)\in E$
    - If this is the case, then $u$ is the sink - otherwise $u$ is not the sink 

A total of $3(n-1)$ accesses

### Bipartiteness and BFS and ADJ Mat (May Well be in Exam)

- Any algorithm that determines if a graph is bipartite that has an input a undirected graph $G=(V,E)$ is bipartite that has as its input a undirected graph $G=(V,E)$ represented as an $n\cross n$ adj matrix, has the running time $\Omega(n^2)$

The lower bound for sorting integers that are only done by comparison is:

- $\Omega(n$ $log$ $n)$

**Proof**

- Pick any algorithm ALG for determining bipartiteness
- For a given arbitrary graph $G=(V,E)$ represented as $n\cross n$ adj matrix A, algorithm ALG
  - Either returns TRUE
  - or Returns FALSE
- Show that ALG must have run time $\Omega(n^2)$
- Consider the behaviour of the ALG on a star graph $G_0=(V,E_0)$ with $V=\{1,2,...,n\}$ and $E_0=\{\{1,i\}:2\leq i \leq n\}$
- In each step of its computation algorithm ALG either accesses an entry in the adj matrix A or does some other computation
- Suppose that for $G_0=(V,E)$ algorithm ALG accesses exactly $L$ entries in the ADJ mat
- $L$ is the lower bound for the running time of ALG

$L=\Omega(n^2)$

For given algorithm ALG construct G1 st:

- If alg performs less than $\frac{n-1}{2}$ accesses to the adj matrix of A of G0
- G1 is not bipartite

Since G0 is bipartite, G1 is not bipartite, and ALG cannot distinguish between G0 and G1, then ALG fails

- Since $L< N\C2$ 
- There must be a pair of vertices $i,j\in V,2\leq i<j \leq n$ such that ALG neither accesses the entry A[i,j] or A[j,i]
- This means there is at least one element which wasn't queried
- ALG outputs the outcome TRUE for the sta without accessing the other entries
- ALG will output the same output for the same output TRUE for the graph
- This is a contradiction since G1 is not bipartite and hence must be different for G0 and G1
- Hence we must have $L\leq N\C2$
- Implies algorithm has time $\Omega(n^2)$

#### BFS running time

- If stored in a ADJ list, then we perform $d(v)$ for every node $v\in V$ 
- Gives asymptotically optimal running time of $O(n+m)$

- The running time is $O(n^2)$ when stored in the adjacency matrix

**Lower Bound**

- the main claim is that is impossible to acheive the $O(n+m)$ time algorithm

- showing $\Omega(n+m)$ is easier
  - Implies that for $m=\Omega(n^2)$ cannot do $o(n^2)$ time

### DFS

Recursive Formulation

![image-20220120092727670](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220120092727670.png)

- For the two versions to be equivalent the forall construct needs to consider edges in the opposite order. (First choose the edge with highest opposite end-point).

#### DFS tree

- Edges not contained in the DFS tree can only connect ancestors and descendants

**Running Time**

Same as BFS

#### Connected Components

- Run BFS or DFS from a vertex 𝑠, and remove the connected component
- Repeat until all the vertices of the graph are exhausted
- If a component 𝐶 has 𝑛𝑐 vertices and 𝑚𝑐 edges, BFS or DFS takes time $𝑂(𝑛_𝑐 + 𝑚_𝑐) $.
- In total takes $O(n+m)$ time

#### DFS Numbering

Compute in which order the recursive calls initiated by the nodes in the network finish

- Active nodes always form a path, even when vertices move into finish



### Directed Graphs

- Algorithms for BFS and DFS are the same as for undirected
- The properties of the trees are slightly different
- **BFS**
  - BFS-tree: the BFS-tree contains a shortest directed path from 𝑠 to 𝑣, for every 𝑣 ∈ 𝑉.
- **DFS**
  - All finish numbers are distinct
  - Child in the tree always has lower number
    - $\Longrightarrow$ ancestor always has a lower number 
  - If $(u,v)$ is a non-tree edge, then
    - Either $N[u]>N[v]$
    - Or $u,v$ have an ancestor/descendant relationship in the DFS forest

**Proof Of Final Statement**

Have an edge u,v - non tree edge

- $N(u)<N(v)\and u,v$ do not have an A/D relationship in the DFS forest
- Active node - already visited but have not yet finished its DFS call
- In any point in time during the DFS search, the active nodes 



The only reason that the edge $U9,v)$ is not part of the DFS tree is that v is already visited when the edge is examined

At this point in time, u has not yet finished its DFS call, therefore, v has not yet finished its DFS call as:

- $N(u)<N(v)$

This means that v is active, it is visited, but has not yet finished its DFS call

- The set of active vertices always form a path in the tree
- Since u is active, this is a contradiction to the fact that u and v do not have an ancestor/descendant relationship

#### DFs tree types of non tree edges

- Forward edge - from a node to descendant
- Backward edge - from a node to ancestor
- Cross edge - non-ancestor, descendant edges

![image-20220124131908284](C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS254.assets\image-20220124131908284.png)

#### Properties of DFS numbering

- All numbers are distinct
- If u is an ancestor of v in the DFS tree, then N[u] > N[v]

If (u,v) a non tree edge

	- Either N(u) > N(v) or
	- They have an ancestor descendant relationship in the DFS forest

![image-20220124131931535](C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS254.assets\image-20220124131931535.png)

- Always from right to left



#### Cycles in digraphs

IF G is undirected that does not contain a cycle, how many edges can G contain

- If no parallel edges, then $0\leq m\leq n-1$
- If

If no parallel edges, then its n choose 2

- A digraph with no edges is called DAG

**Definition**

Left $G=(V,E)$ be a digraph

A topological sort is a map $\phi:V\rightarrow \{1,...,n\}$

- $\forall(u,v)\in E$  $\phi(u)<\phi(v)$

**theorem**

A digraph has a topological sort iff it is a DAG

**Proof**

$\Rightarrow$

- Suppose G has a top sort,
- Assume that G has a cycle C=$(x_0,....,x_k)$
- WLOG let $x_0=$arg($min_{i\in\{1,...,k\}}\{\phi(x_i)\})$ 
- Then $(x_k,x_0)\in E$ but $\phi(x_k)\geq \phi(x_0)$

$\Leftarrow$

<img src="C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS254.assets\image-20220124133348946.png" alt="image-20220124133348946" style="zoom:50%;" />

#### DAG algorithm - topological order

Can have a tree, forward, and cross edge

- Every backward edge creates a cycle

<img src="C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS254.assets\image-20220124133742041.png" alt="image-20220124133742041" style="zoom:67%;" />

##### Checking a Digraph is a DAG

<img src="C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS254.assets\image-20220124133949486.png" alt="image-20220124133949486" style="zoom:67%;" />



#### Connected Components

- $G=(V,E)$ - undir
- Two vertices are connected, if there is a path from u to v
- Relation of connective is reflexive, symmetric and transitive - an equivalence relation
- This requivalence relation defines a partition of V into disjoint sets, called the connected componentes of G

<img src="C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS254.assets\image-20220124134236520.png" alt="image-20220124134236520" style="zoom:67%;" />

## Strongly Connected Components

- $G=(V,E)$
- Two vertices are connected if there is a path between edges in each way, once again equivalence relation
- Defines a prtition of v into disjoint sets called the strongly connected components of G

Can be considered separately 

- There is a dag betwen each Strongly Connected Component

### Finding all Strongly Connected Components

- Compute a DFS umbering for G
- Computer a graph G' obtained from G by reversing all edges
- Start a DFS in G' where the starting/restarting is alays done with the node v that has the maximum  of 𝑁 𝑣 among the yet unvisited nodes
- Trees generated in this run are strongly connected components

​	

### Write Proof Here (ABOVE THING)

### Uses of strongly connected components

- often use the decomposition of the input graph into strongly connected components jointly with topological sort, to design efficient algorithms for otherwise difficult problems
- Let G be a digraph
- Find the strongly connected components of G
- Contract each one into a single vertex



1. Find strongly connected components, then contract each
2. Topologically sort the contracted components
3. Use dynamic programming on DAGs to solve a problem



## Bi Connected Components in Undirected graphs

An undir graph G is biconnected if $G$ \\ $\{v\}$ is connected for all v

A cut vertex or articulation point is a vertex whose removal disconnects the graph

A maximal biconnected subgraph of G is a biconnected component of G

### Equivalence relation

- Connected components are strongly connected components are the equivalence classes of certain equivalence relations

let ~ be the relation on E such that e1~e2 iff e1 and e2 are contained in a simple cycle in G or e1 = e2

![image-20220131131056855](C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS254.assets\image-20220131131056855.png)

### General:

The root is an articulation point iff it has two or more children

- There are no cross edges.
- In the DFS tree:
  - Technically, the edges go in both directions, therefore, $N[u]>N[v]$, but this would also be the other way round

The leaf can never be an articulation point

**An Internal vertex point is an articulation point:**

- Iff there is a child $u$ of $v$ such that no edges connect a node from the sub tree $T_u$ rooted at $u$ to an ancestor of $v$

**Definition**

The low point of a node v in the DFS tree is the lowest level among the neighbours of nodes in the sub tree $T_v$ rooted at $v$

### Algorithm

- Compute a DFS tree
- Compute for each node its level in the DFS tree
- Compute for each node its low point
- Check for each internal node its low point
- Check for each internal node v in the DFS tree, whether the low point of one of its children is larger or equal to $v$'s level. If this is true $v$ is an articulation point, otherwise not
- Incorporated into one DFS cycle

<img src="C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS254.assets\image-20220131132648252.png" alt="image-20220131132648252" style="zoom: 33%;" />

#### Viewpoint of a Single node

In DFS call, we're in node x in level l

1. Call DFA to all unvisited neighbours y of x
   - Edge $\set{x,y}$ becomes a DFS tree edge
   - Level of y is equal to l + 1
2. Invariant: we already know the low point of all descendants of x
3. Compute low-point of 𝑥 (initially low-point(𝑥) = level of 𝑥)
   - For every edge  $\set{x,y}\in E$
     - If x is a descendant of y, then update low point of x
       - Low point x = min$\set{lowPoint(x), level(y)}$
     - If x is the parent of y the update low point x
       - Low point x = min$\set{lowPoint(x), lowPoint(y)}$
     - If x is the parent of y, then check if x is an articulation point
       - If $lowPooint(y)\leq level(x)$ then mark x as an articulation point

#### Running Time

Runs in $O(n+m)$ - in one run of DFS

- Can be extended to find all biconnected components in $O(n+m)$ time



## Bipartiteness in DFS

![image-20220131134101523](C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS254.assets\image-20220131134101523.png)

The level set $L_i$ contains nodes at distance $i$ from the root

- G is bipartite iff each connected component of G is bipartite
- Connected G is bipartite iff every cycle in G is even
- If $\set{u,v}\in E$ with u,v both on odd level $\rightarrow$ consider cycle from $u$ to their least common ancestor $z$ then from $z$ to v and then $\set {u,v}$ 



**If G has no edge, containing two vertices on odd or on even, then G is bipartite**

Create a bi colouring of the graph, 

- V0 vertices on even levels
- V1 vertices on odd levels

### Any Graph Exploration can be used for bipartiteness

- Any graph exploration generates a spanning tree T 

## Problems in Trees and DAGs

- Longest simple path - NP hard:
  - Easy for trees:
    - $O(n)$
  - Easy for DAGs
    - $O(n+m)$

### Finding the longest simple path in a forest

- If each UNDIR graph G is acyclic, then G is a forest
- Each connected component is a tree
- Find the longest simple path in each tree
- First compute length
- Choose a node r, and run DFS from r

Bottom up: start in a leaves,

Top down: start in root.



- At any vertex u
  - LP will be fully in the subtree rooted at $u$ or else - $LPI(u)$
  - LP will go through $u$, or - $LPT(u)$
  - LP will not visit the subtree rooted at $u$ at all



#### LPI

- Longest path contained fully in the subtree rooted at u and not using u, can be obtained from the longest paths from children ( +2 edges connecting them to $u$)

![image-20220201162226943](C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS254.assets\image-20220201162226943.png)



### 3 Cases:

Longest is part of u

<img src="C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS254.assets\image-20220201162547872.png" alt="image-20220201162547872" style="zoom:33%;" />

Longest not part of u

<img src="C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS254.assets\image-20220201162609736.png" alt="image-20220201162609736" style="zoom:33%;" />

Longest goes through u

<img src="C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS254.assets\image-20220201162711822.png" alt="image-20220201162711822" style="zoom:33%;" />





## Longest Simple Path in a DAG

- If a DAG is acyclic, then can be topologically osrted
- In $O(n+m)$ time, we can reunmber so that
  - If $(i,j)\in E$ then $i<j$
- This implies that any path will have increasing numbers:
  - $\langle i_1,i_2,...,i_s\rangle $
- Will only compute the length
- Let LP(i) be the length of the longest path starting at i

$LP(i)= max\set{1+LP(j)}:(i,j)\in E$

<img src="C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS254.assets\image-20220201163323417.png" alt="image-20220201163323417" style="zoom:33%;" />



## Graph Colouring

- Let G be a graph, and let C be a set of colour of G with colour set C is a function $c:V\rightarrow C$ such that $c(u)\neq c(v)$ for all edges $(u,v)\in E$

Easy for 1,2 and n where the graph is a clique

**Chromatic Number**

- $\Chi(G)$ of a graph G is the smallest k such that there exists a k colouring of G



#### Bounds on $\Chi(G)$ 

<img src="C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS254.assets\image-20220201164058374.png" alt="image-20220201164058374" style="zoom: 25%;" />

Given a graph $G=(V,E)$ the clique number $\omega(G)$ is the cardinality of the largest subset 𝐾 ⊆ 𝑉, such that 𝐺[𝐾] is a complete graph, where 𝐺[𝐾] is the subgraph of 𝐺 induced by vertex set 𝐾.

**Lemma**

If a graph contains a k clique, then the chromatic number is at least k



**Algorithm**

![image-20220201164448799](C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS254.assets\image-20220201164448799.png)



**Lemma**

- Greedy Colouring colours G with at most $\Delta(G)+1$ colours



**Theorem**

- $\Chi(G)\leq\Delta(G) + 1$

### Planar Graphs

- Graphs where the edges cannot cross
- A graph is planar, if it can be drawn in the plane $R^2$ with every vertex drawn as a point $f(v)\in R^2$ and ever edge $(u,v)$ drawn as a continuous curve between $f(u),f(v)$ such that no two edges intersect

Given a planar graph, in addition to the vertices and edges of the drawing, also have faces of the drawing. The faces are connected components of $R^2$ after we delete the vertices and edges of the drawing

Every cycle is planar, every tree is planar

### Euler's Formula

Let G be a connected planar graph. Let F be the sets of faces of a planar drawing of G, then $|V|+|F|=2+|E|$ 

**Proof**

- by the number of cycles

If 𝐺 is acyclic, then |𝐹| = 1, and the theorem holds since 𝐺 is a tree and |𝐸| = |𝑉| − 1.

 Otherwise 𝐺 has a cycle. Let 𝑒 be an edge in a cycle. Delete 𝑒 from 𝐺 and let 𝐺^∗^ be the resulting graph.

<img src="C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS254.assets\image-20220203090925962.png" alt="image-20220203090925962" style="zoom: 25%;" />

#### If G is not connected:

- $|V| + |F| = 1 + cc_G + |E|$

Where $cc_g$ is the number of connected components.

#### Applications

For any simple connected planar graph G with $n>2$ it holds that $|E| \leq 3n -6$

- This means the graph is sparse - a linear number of edges (kind of not defined)

**Proof**

- Every face has at least 3 edges bounding it
  - This requires the fact that $n$ is at least three - a line between the two
- Every edge bounds at most two faces
  - In some cases only one.

![image-20220203091846645](C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS254.assets\image-20220203091846645.png)

This implies that:

- $2|E|\geq 3|F|$ 
- <img src="C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS254.assets\image-20220203092118962.png" alt="image-20220203092118962" style="zoom:50%;" />





**Lemma**

Every planar graph has a vertex of degree at most 5

**Proof**

Suppose all vertices are of degree $\>5$

Then the following holds:

<img src="C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS254.assets\image-20220203092742291.png" alt="image-20220203092742291" style="zoom:33%;" />

But we know that for $n>2$ $|E|\leq 3|V|-6$ 

**Corollary**

-  Every simple planar graph is 6-colourable

Since G has a vertex of degree $\leq 5$ then recursively:

- Find a vertex $v$ with $d(v)\leq5$
- Recursively colour $G-v$ using 6 colours
- Extend the 6 colouring of $G-v$ by colouring v in a colour distinct from the colours of its $d(v)\leq5$ neighbours

$\square$ 

####  Corollary

Every simple graph is 5 colourable

**Proof**

If G has a vertex of degree $\leq4$ then we are done by induction as in the previous proof

Else, it has a vertex of degree 5:

- Remove $v$ from $G$ and colour the obtained graph, and bring $v$ back

- $G-v\rightarrow G$

If among the 5 neighbours of v in G, not all 5 colours are used, then we may colour v the missing colour and we are done

**Otherwise:**

$v$ has 5 neighbours, WLOG, vertex $u_i$ with colour $i$. WLOG they're arranged in clockwise order

Try to replace the colour of $u_1$ with colour 3.

Consider the subgraph $H$ of $G$ induced by vertices with colours 1,3

- If $u_1$ is disconnected from $u_3$ in H, then consider the component of $H$ containing $u_1$ and swap colours 1 and 3 in that component - this is still a proper colouring

- Therefore can colour vertex $v$ with colour 3

**Otherwise:**

- They are in the same connected component:

Otherwise, take path $\pi$ from $u_1$ to $u_3$ in H

- If we add edges $\set{v,u_1}$ and $\set{v,u_3}$ to $\pi$ we obtain a Jordan curve separating from $u_2$ from $u_4$
- Therefore the graph induced by the vertices coloured 2 and 4 cannot have $u_2$ and $u_4$ connected. Therefore, in that graph, in the component containing 𝑢4 swap colours 2 and 4.

#### **Theorem**

- Any planar graph is 4 colourable



### Duals of Planar Graphs

The dual graph $G^*(V^*,E^*)$ of a planar graph $G$

- Each vertec $u\in V^*$ corresponded to a face in G
- Two vertices in $G^*$ are connected by an edge if the corresponding faces in $G$ have a boundary edge in common

<img src="C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS254.assets\image-20220203094558264.png" alt="image-20220203094558264" style="zoom:50%;" />

# Spanning Trees

- Undir connected graph G
- Spanning tree ST is a maximal spanning subgraph of G with no cycle
  - A connected subgraph of G with $|V|-1$ edges
  - Every vertex is incident to at least one edge
  - MST if a spanning tree G with the minimum weight





Meta Algorithm

- Build the ST edge by ege
  - Either including an appropriate low weight edge
  - Or by excluding an appropriate (high weight edge) one
- Until a tree is built

Can be desgcribed as a colouring algorithm that colours the edges one by one

- the included edges are blue, and excluded are red

Key colouring invariant of the algorithm

- there is a MST containing all of the blue edges and none of the red ones



**Cases**

- suppose we have a partition of V into V1 and V2 and let G1 and G2 be the subgraphs of G vertex induced by V1 and V2
  - Colour the one with the lowest cost
  - S
- Suppose there is no blue edge connecting G1 and G2, how to choose a single edge e to connect G1 qnd G2 to ensure that e is in the MST of G - e is green
  - Choose the lightest edge

**Blue rule**

Select any partition of V into V1 and V2 with no blue edges connecting V1 and V2. Among the uncoloured edges connecting V1 and V2, colour the lightest edge blue

**Red rule**

(Select any simple cycle containing no red eges. Among the unclouored edges on the cycle, colour one edge red - the one with the ighest cost)

A cycle where some edges are blue

- one needs to be coloured red, choose the heaviest non-blue edge



## Meta Algorithm

- Initialisation - all uncoloured
- Whilw there are uncoloured eges
  - Apply either red or blue
- Return tree



### Theorem

The meta is correct

- If G is a connected undirected graph, then the meta-algorithm returns a minimum spanning tree

This is a generic algorithm

## Kruskal MST Algorithm

- All edges are uncoloured, sort all edges in non-decreasing order
- For all edges in non-decreasing order
  - Apply blue or red rule to colour e
- return tree formed by blue edges

## Prim

- all uncoloured
- Repeat n-1 times
  - Let T be a blue tree containing s
  - Select a min weight edge e incident to T
  - Colour e blue
- Return the tree formed by the blue edges



## Proof of META Algorithm

- show that it satisfied the colouring property
- Terminates

**Proof**

initially, no edge is coloured an any connected undirected graph has an MST -> invariant is satisfied at the beginning ofthe  algorithm

Suppose the invariant is satisfied before a blue rule is performed

Let e be an edge coloured blue in this step

Let T be an MST satisfying the invariant before colouring e

If $e\in T$

- Then the claim is satisfied

If $e\notin T$

- Show other MST containing e

- Let V1 and V2 be the vertex sets in the partition that caused the blue rule to be applied to e

- There must exist a path in T between endpoints of e and at least one edge e* in the path must connect a vertex from V1 to a vertex in V2
- e* is uncoloured and we coloured edge e
  - Cost of e* is greater or equal to e
- There





**Red Rule**

Suppose the invariant is satisfied before a red rule is performed

Let e be an edge coloured red in this step

Let T be a MST satisfying the invariant before colouring e

$e\notin T$ the tree satisfying the invariant after colouring e

otherwise $e\in $T

- Let V1 and V2 be the vertex sets in the two subtree maintaining of T obtained after deleting e from T when we applied the red rule to e, there was a cycle C containing e and some other edges with weight less than or equal to e
- $w(e)\geq w(e^*)$ for any $e^*\in C$
- Remove the edge e from the MST
- The new edge will have a lowlow weight, and still maintaining the invariant
  - Since exactly one of the en

an

**termination**

Suppose by cont. that the algorithm is unable to perform either blue or red rule, while some edges of G are uncoloured

Let e be any uncoloured edge

We have shoen that before entering any execution of the WHILE looop, the colouring property is satisfied -> before stopping the algorithm the blue edges form a forest - consisting of blue trees

To argue which edge is applied, take a cut of one tree two another, must be one edge which is not coloured blue

- take the lightest edge, which can then be coloured blue, which is between the two cutsets

**Correctness**

- If G is a connected undirected graph, then the meta-algorithm returns a minimum spanning



The theorem about META algorithm 



### What is needed for the meta algorithm

Red rule

Blue rule

for the current forest induced by blue edges:

- If the examined edge $e$ is between different trees:
  - If $e$ is the lighteste edge between these trees -> colour $e$ blue
- If the examined edge $e$ is inside one of the trees -> colour $e$ red

Need a data structure that allows us to check these conditions quickly

## Dynamic Data Structures

Union Find

- Maintain a collection $S=\set{s_1,...,s_k}$ of disjoind dynamic sets supporting the following operations
  - $MakeSet(x)$ creates a new set whose only member is $x$
  - $Union(x,y)$ unites the dynamic sets that contain $x,y$ into a new set that is the union of these two sets
  - $Find(x)$ returns a pointer/representative of the set containing $x$
- typically need $O(n)$ UNION and $O(m)$ FIND oprerations
- Each set $s_i$ contains vertices from the same blue tree

<img src="C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS254.assets\image-20220210091017191.png" alt="image-20220210091017191" style="zoom:50%;" />

Simplest implementation of union find data structure uses characteristic vectors

- O(1) for each operation MakeSet()
- $O(1)$ for find
- $O(n)$ for the rest, including union

- This means that with this data structure, the implementation is $O(m+n^2)$ time

### Better implementation

- More common/better implementation of union find data/structures uses the tree structure
- We have a collection of sets corresponding to the tree x and y belong to the same tree iff x,y, 
  - Representative of a set = the root of the corresponding set
  - Each node has a link to its parent in the tree
  - Parent of a root is the node itself



#### Make Set

- Create a new tree rooted at x, $PARENT(x)=x$ 

#### Union

- $PARENT(FIND(x)):=FIND(Y)$ 

#### Find

- $y:=x$
- **While** $Y\neq PARENT(y)$ do
  - $Y:=PARENT(y)$
- **Return** $Y$ 

#### Complexity

- Inefficient
  - ![image-20220210092141502](C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS254.assets\image-20220210092141502.png)



- This is $O(n(n+m))$ which is worse than characteristic vector

- Balance the tree by using a red,black tree of an AVL tree
- This makes the height $O(log$ $k)$, for  $k$ nodes in the tree.
- Union  tends to increase the height
- Ideal is to have one root, and all its children beneath it
  - Every node has exactly one parent

#### Path Compression

- each time we perform FIND(c) we change the PARENT link for all the nodes on the path x to the root to point to the root in the tree

#### Weight Union Rule

- In $UNION(x,y)$ let WLOG the number of nodes in the tree containing x be larger than or equal to the number of nodes in the tree containing $y$; set $PARENT(FIND(Y):=FIND(x)$

To implement this, we need to maintain the number of nodes in each tree

- If FIND(x) > 

#### Height Union Rule

- in $UNION(𝑥, 𝑦)$, let wlog the height of the tree containing 𝑥 be larger than or equal to the height of the tree containing 𝑦; set PARENT(FIND(𝑦)): = FIND(𝑥).



#### Ackermann's Function $A_k(j):$

<img src="C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS254.assets\image-20220210094314005.png" alt="image-20220210094314005" style="zoom:33%;" />

<img src="C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS254.assets\image-20220210094825766.png" alt="image-20220210094825766" style="zoom: 25%;" />



It is very rapidly growing

The inverse is $\alpha(n)$

- $\alpha(n)=min\set{k:A_k(1)\geq n}$

- The inverse is very small for this



**Theorem**

- A sequence $m$ MAKE-SET, find and UNION operations performed with path compression rule and either with the weight union rule or with the height union rule, has worst case running time of $O(m\cdot\alpha(n))$ 

### Kruskals with this

A total running time of $O(n+m$ $log$ $n)$

- If all the weights of the edges are integers, less than $N^2$, the time complexity of sorting is linear, the running time is
- $O(n+m\cdot\alpha(n))$

# Prim's algorithm

### MST

- Assuming input graph is connected
- Assuming graph is simple
- Can removea ll self loops and if there are parallel edges, then keep the lightest one

- Assume $n-1\leq m\leq $ $n\choose 2$

- Therefore $log$ $m =\Theta(log $ $n)$
- As $m$ is at least $n-1$, this is the same as $n*$ somethine

### Algorithm

- Initialisation: all edges are uncoloured
- **Repeat** $n-1$ times
  - Let $T$ be a blue tree containing s
  - Select a min-weight edge e inciedent to $T$
  - Coloure $e$ blue
- **Return** The tree formed by blue edges

### Running Time

- Easy implementation in $n(n+m)$ time
- R

**Tool**

- For any vertex $v\in V\backslash T$ define:
  - $d(v)=min\set{w(v,u):u\in T, (v,u)\in E}$ 
  - $\pi(v)=u$ such that $w(v,u)=d(v),u\in T,(v,u)\in E$ 

<img src="C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS254.assets\image-20220214132720701.png" alt="image-20220214132720701" style="zoom:33%;" />

- After adding a vertex, remove an item from the tree.
- Only edges adjacent to the vertex added will need to be considered.

For all vertices in:

<img src="C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS254.assets\image-20220214133336669.png" alt="image-20220214133336669" style="zoom:33%;" />

Leads to an implementationn of $O(n^2)$ 

- Initialisation: $O(n)$
- Finding $O(n)$
- Decrease key:
  - $O(deg(v))$

<img src="C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS254.assets\image-20220214133505993.png" alt="image-20220214133505993" style="zoom:33%;" />

**Improvement:**

- if you use a priority queue, then this can be done in:
  - $log(n+m$ $log$ $n)$

- Also can use a heap: standard PG implementation, whi h supports each of the oeprations in $O(logn)$ time
  - Find Min - constant
  - INSERT
  - DELETE
- For every element, its parents had smaller value

**Using fibonacci heap**

- $O(n$ $log$ $n+m)$ - faster for dense grpahs



## Efficient Algorithms for MST

- Kruskal
  - Standard implementation (using UNION-FIND) runs in 𝑂(𝑚 log 𝑛) time • If edges are sorted according to their weights (or we can sort them in linear time) then UNION-FIND data structure gives 𝑂(𝑚 𝛼(𝑛)) runtime
- Prims
  - Simple implementation gives 𝑂 𝑛 2 runtime • Simple implementation using priority queues gives 𝑂(𝑚 log 𝑛) runtime • Advanced data structures (Fibonacci heaps) give the running time of 𝑂(𝑚 + 𝑛 )
- Boruvka 
  - Good for parallel processing

# Round Robin MST Algorithm

- Initialise $Q:=V$ queue defining a parition of V
  - Each set in Q corresponds to a connected component of blue edges
- **Repeat**
  - Let A be the first element of $Q$
  - Apply blue rule to $A$ and $V\backslash A$
  - Let $\set{x,y}$ be the new blue edge
  - Let $x\in A,y\in B$ for some set $B$ in $Q$
  - Delete $A$ and $B$ from $Q$
  - Add $A\cup B$ to $Q$
- **Return** the tree formed by blue edges





**Stage 1:**

- Ends when the last element from the original set Q id deleted

**Stage i:**

- Ends when the last element from $Q$ from the beginning of the stage is deleted

**Notion of stages is irrelevant to the POV of the algoritm,**







## Lemma:

- Sets entering stage $k$ have size $\geq2^{k-1}$; produced in that stage have size $\geq2^k$

## Corollary:

- There are at most $log$ $n$ stages

**Proof**

By induction

For stage 1, clearly all sets are of that size; each are of size 1

If the claim holds for stage $k-1\geq1$ 

- Any new set created in stage $k$ is a union of a set created in stage $k-1$ and set created in either stage $k$ or stage $k-1$
- Since sets created in $k$ are not smaller than the sets created in stage $k-1$ 
  - A set created in set $k$ is a union of two sets , each of size $2^{(k-1)-1} $ by induction
  - The size of the new set is two times this



## Runtime

- Sum of all vertices in $\Sigma_{v\in A}deg(v)$
- Since sets $A$ in a single stage are disjoin, running time of a stage is $O(m)$
- As there are at most $\log n$ stages, the running time is $O(m\log n)$
  - This can be improved to $O(m\log\log n)$ - better than all before but kruskal if the edge weights are integers
  - Prim's is better with less dense graphs



This is better in sparse grpahs

- Works well for planar graphs



## Properties

- Any simple planar graph has at most 3n edges
- GRaph contraction:
  - Contract every blue tree into a single -supervertex
  - Delete all edges between two vertices in the same tree
  - Multiple edges between different tree, delete all but the lightest

**A contraction of a simple planar graph gives a simple planar graph**

- Modified, with contraction at each stage



## Round Robin in Planar Graphs

Planar graph:

- $k=1$
- $G_k=1$

While $G_k$ has more than one vertex do:	

- Run a single staeg of Round Robin
- Contract $G_k$ into $G_{k+1}$ 
- $k=k+1$

- 

### Runtime

- A staage starting with a simple planar graphs with N vertices requires $O(N)$ time
- Contraction of a simple planar graph with $N$ vertices requires $O(N)$ time

In stage 1, we started with $n$ vertices

In stage 2, at the beginning each tree has $\geq2$ vertices, $G_2$ has $\geq n/2$ vertices

In stage $k$, we consider with $\leq n/2^{k-1}$ 

![image-20220215164848818](C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS254.assets\image-20220215164848818.png)



- This improves the algorithm to $O(m\log\log n)$



## Fast Round Robin Algorithm

1. Run $\log \log n$ stages of round robin

   1. Let $U_1,...,U_k$ be the sets in $Q$ at the end
   2. Since $|U_i|\geq 2^{\log \log n}=\log n$, $k\leq n/\log n$

2. Contract the graph $G$ with respect to the sets $U_1,...,U_k$ 

   1. Define 	$G'=(V',E')$ such that $V=\set{U_1,...,U_k}$ and $E'$ has an edge connecting $U_i,U_j$ iff $G$ has an edge between $U_i,U_j$ 
   2. Modify the weights in $G':w'(\set{U_i,U_j})=\min\set{w(\set{x,y}): x\in U_i,y\in U_j}$ 

3. Modify $G'$:

   1. Divide edges incident to $U_j$ in $\lceil\deg(U_i/\log n)\rceil$ groups of $\geq\log n$ edges each 

   2. We do not find the lightest edge {𝑥, 𝑦} as we discussed above, but instead, for every vertex 𝑈𝑖 ∈ 𝑉′ we inspect the edges in groups.

   3. For every group, inspect the edges by increasing cost $w'$ and discard edges which do not lead outside the set $X\in Q$ 

   4. When the process is finished, there are $\lceil deg(U_i)/\log(n)\rceil$ leading from $U_i$ outside $X$ , therefore the lightest one can be found in $O(1+\frac{\deg(U_i)}{\log n})$ time

   5. Then sort each group according to the weights of their edges $w'$ 

      Since each group has $O(\log n)$ edges, total a running time is $O(\log \log n)$ 

   6. Therefore the cost of finding the lightest edges going out of edges going out of $U_i$ $O(1+ no.$ $discarded$ $+ \frac{\deg(U_i)}{\log n})$ 

   7. Since every edge is discarded at most once, since there are at most $\log n$​ stages and since $k\leq n/\log n$, the total cost is $O(n+m)$ 

<img src="C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS254.assets\image-20220217094714522.png" alt="image-20220217094714522" style="zoom:33%;" />



#### Running Time

$O(\log \log n)$  times with $O(n+m)$ per stage

Contraction $O(m)$ time

Sorting edges $O(m\log\log n)$ time

Final calls to round robin $O(n+m)$ 



# Matching Algorithms

- Input undirectegd graph $G=(V,E)$
- A matching subset $H$ of the edges such that no two edges in $H$ share an end point
- 



Find a matching of maximum cardinality

In the cases that edges are weighted - non negative, aim to find a mathcing of maximum weight.

## Bipartite MAtching

- Undir birpartite graph, $L,R$ are the two vertex sets
- $M\subseteq E$ is a amtching if each node appears in at most one edge in $M$
- Max matching - find a max cardinality matching
- A matching is perfect if $|M|=|L|=|R|$

Can be reduced into maximum flow

- Given a digraph G
- With two epecial vertic, $s,t$
- with the capacity on every edge
- find an $s,t$ flow of maximum value

$f$ satisfies the following

- $0\leq f(e)\leq c(e)\forall e\in E$
- $\Sigma_{(u,v)\in E}f(u,v)=\Sigma_{(v,w)\in E}f(v,w)\forall v\in V\backslash \set{s,t}$

![image-20220221132404418](C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS254.assets\image-20220221132404418.png)

- max flow can be done in time $O(nm)$

## Reduction

MAx flow formation

- digraph $G'=(L\cup R\cup \set{s,t},E')$, and assign infinite or unit capacity
- Add a source $s$ and unit capacity edges from $s$ to each node in $L$
- Add sint $t$ and unit capacity edges from each node $R$ to $t$

<img src="C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS254.assets\image-20220221132806710.png" alt="image-20220221132806710" style="zoom:25%;" />



### Proof:

Theorem: Size of a maximum matching in 𝐺 is at most the value of a max flow in 𝐺′

- Given max matching $M$ of cardinality $k$
- Consider flow $f$ that sends 1 unit along each of $k$ paths
- $f$ is a feasible flow and has cardinality $k$

$\blacksquare$

Is at least value of the max flow

- Let $f$ be a max flow in $G'$ of value $k$

- Integrality theorem $\implies k$ is integral and we can assume $f$ is 0/1
- Consider $M=$ set of edges from $L$ to $R$ with $f(e)=1$
- Each node in $L,R$ participates in at most one edge in $M$
- $|M|\geq k$ since the flow must use at least   $k$ edges

$\blacksquare$



## Augmented Path

- Given a matchin $M$ in $G$ a vertex that is not incident to any edge of $M$ is called a free vertex
- For a matching M a path in P in G is called an alternating path if eges in M alternate with edges not in M
- An augmented path is an alternating path that starts and ends at distinct free vertices
  - The length of the path is always off
  - There is always one more edge in m than not in m

### Theorem

A matching M is maximum iff there is no augmenting path with respect to M

### Proof

#### $\implies$ 

If M is maximum, then there is no augmenting path wrt M

Because we could switch matching and non-matching edges along the path. This would give a matching $M'=M\oplus P$ - only edges that are in M or P but no both - with larger carinality

#### $\Longleftarrow$ 

Suppose there is a matchin $M^*$ with $|M^*|>M$

- consider the graph $H$ with edge set $M^*\oplus M$
- Each vertex in $H$ can be inccident to at most two edges (one from M and one from M*).
- Hence the connected componentes of $H$ are alternating cycles or alternating paths, each of the cycles will have an equal number of red and blue edges
- Every cycle has the same number of edges from M and M^*^ 
- Paths may have different number of edges from each, but this will be at most 1
  - As M* > M

- Since any path with more edges from M* than from M is an augmenting path wrt M

​			$\implies$ number of augmenting paths wrt $M\geq |M^*|-|M|$

<img src="C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS254.assets\image-20220221135143667.png" alt="image-20220221135143667" style="zoom:25%;" />

#### 





































































































































