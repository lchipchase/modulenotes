# CS254 Algorithmic Graph Theory

## Week 1 - lecture 1



Key points

- understanding basic properties of graphics and design efficient algorithms
- Designing efficient algorithms for graph problems
- Analysing algorithms and proving correctness

Motivated typically by IT/CS

Running and correctness to determine the quality of the algorithms

### Introduction

#### Basic definitions

Graph definitions (according to module)

Graph:

- A pair of vertices and edges $G=(V,E)$
  - V are vertices / nodes
  - E are pairwise relations of elements of V
- Undir graph $G=(V,E)$  (typically this is the type which will be looked at)
  - V are vertices
  - E are edges - a set of sets of pairs of edges
- di Graphs - simple
  - V a set of vertices
  - $E\subseteq V \cross V$ edges, where E is non - reflexive
- Undir multigraph - pseudograph
  - A set of V vertices
  - A multi set E of edges that consist of two-element multi-sets over elements V
- Directed multigraph
  - The same as a digraph, but allows multiple elements
  - $E\subseteq V\cross V$ -
    - Terminology - sometimes an edge is an arc
- Order of a graph
  - The cardinality of the vertex set, usually use $n$ to denote $|V|$
- The size of a graph is the cardinality $|E$| of its edge set
- A graph that does not contain , multi edges or self loop is called simple

- An edge $e$ is incident to a vertex $v$ if:
  - $v\in e$ for undirected graphs
  - $e=(v,x)$ or $e-(v,x)$ with $x\in V$ 
- The two vertices an edge e is incident to are called the end points of e
- Two vertices u and v are adjacent if there is an edge e that is inciden to both of them
- Two edges are called adjacent if they share some commone vertex
- For a digraph, $u$ is called the tail and v s called the head
- The degree is the number of edges incident to it
  - Self loop is counted twice
- Inand out degreee in a digraph
- $deg(vv) = indeg(v) + outdeg(v)$
- $\sum_{v\in V} deg(v)=2E$

- $\Delta$ is denoted for the maximum degree of a graph
- A sequence is called a path if:
  - $\forall i \in \{1,…,k-1\}:\{v_j, v_{i + 1}\}\in E$
- The length is the number of its edges
- A path is called a cycle if it has the same start and end point
- Is simple if al; vertices are distinct
- A cycle is simple if the vertices are distinct  - bar the start and finish
- A cycle of odd(even) length is called an odd(even) cycle

Graph connection

- Call a undir graph G connected if there exists a u,v path for ever pair of vertices u and v
- We call a digraph G connected if for ever pair for vertices u,v there exists either a u v path or a  v u path
- Call a digraph strongly connected if for every pair of vertices u,v there exists a u,v path and a v, u path

Subgraph terminology

- A subgraph if the edges and nodes are a subset of the original graphs
- Induced subgraph of $G$ if it is a subgraph of $G$ and $E’$ contains all edges of $E$ with end points in $V’$ 
- A subgraph of $G’=(V’,E)$ of a graph $G=(V,E)$ is called spanning if $V’ = V$

- undir graph that does not contain a cycle as a subgraph is a forest
- An undir graph, connected graph that does not contain a cycle as a subgraph is called a tree
- A spanning subgraph of a graph $G$ that is a tree called a spanning tree of $G$

DAG

- a directed graph that does not contain a cycle is called a DAG
- Has a maximum of $\frac{n(n-1)}{2}$ 
- $V=\{1,…,n\}$
- $E=\{(i,j), i <j\}$

Bipartite graphs

- An undir graph $G=(V,E)$ is called bipartite if the set $V$ can be decomposed into subset $V_1,V_2$ such that
- $V=V_1\uplus V_2$

### Testing Bipartiteness

Is there a partition of $V$ into two set $V_1$ and $V_2$ such that $V_1,V_2$ are independent sets

- WLOG add the first node into $V_1$ 

Use a two colouring 

- The second must be in $V_1$

#### Corollary

A graph that contains an odd cycle is not bipartite

- A graph is not bipartite iff G contains an odd cycle



### BFS and Bipartiteness

P1 - Edges not contains in the BFS tree can only connect successive layers or may connect nodes on the same layer

P2 - The BFS tree contains a shortest (s,v) path for every node v reachable from s

- Run  BFS and analyse the structure of the explored graphs
- Consider only connected graphs

**Lemma**

G is bipartite iff there is no edge u,v with u and v on the same level in the BFS tree

A graph is bipartite iff it does not contain an odd length cycle

**P2 Shortest path property**

- The nodes are added to the BFS tree in non-decreasing order of distance to s

![image-20220117132235873](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220117132235873.png)



- By the prooof above, we know that nodes are added to T in non-decreasing order
- Proof by cont:
  - Assume that v is the node closest to s in G for which no shortes s,v path is contained in T]
- Let u denote the predecessor of v in some shortes s,v path and let x denote the predecessor of v in T
- Then some shortest s,u path will be contained in 

![image-20220118160925868](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220118160925868.png)

**P1 Proof**

- $\{u,v\}\in E$ so that u is on layer l, v is at layer l'. $l<l' - 1$
- $dist(s,v) = l' - 1, dist(s,u) = l$
  - $l + 1 \geq l'$
  - Contradiction

## Graph Representation

- BFS algorithm runs in time $O(n+m)$ to determine if an undirected graph is bi partite, if the graph is represented by adjacency lists

### Adjacency list advantages

- Go thorugh all vertices in $O(n)$ time
- For every vertex $v$ we can go through all neighbours of $v$ time $O(d(v))$
- Checking if $(u,v)\in E$ requires $\Theta(min\{d(v),d(u)\})$
- Topological sort can be done in O(m+n)

### Adjacency Matrix Advantages

- Go through all list of vertices in $O(n)$
- Checking if an edge, can take $O(1)$ time



### Problem

- Simple digraph $G=(V,e)$ a vertex $u\in V$ is a sink if:
  - In $deg(u)=n-1$
  - out $deg(u)=0$
- Given a simple digraph $G=(V,e)$ one can find all its sinks in time $O(n)$

**Claim** no simple digraph has more than one sink

Suppose G has two or more sinks

- Let $u,v\in V$ be two sinks
- Since u is a sink, $indeg(u)=n-1$ and $outdeg(u) = 0$
- Means that $(u,v)\notin E$

**Algorithm**

Check u,v $\in E$

- This will tell us that there is at least one of $u,v$ is not the sink
- If $uv \in E$ then u is not a sink, 
- If $u,v \notin E$ then v is not a sink,
- After $n-1$ tests, there will be only one vertex surviving.
  - Cannot know if it is a sink
  - Check every vertex $v\in V$
    - $(u,v)\notin E$ and $(v,u)\in E$
    - If this is the case, then $u$ is the sink - otherwise $u$ is not the sink 

A total of $3(n-1)$ accesses

### Bipartiteness and BFS and ADJ Mat (May Well be in Exam)

- Any algorithm that determines if a graph is bipartite that has an input a undirected graph $G=(V,E)$ is bipartite that has as its input a undirected graph $G=(V,E)$ represented as an $n\cross n$ adj matrix, has the running time $\Omega(n^2)$

The lower bound for sorting integers that are only done by comparison is:

- $\Omega(n$ $log$ $n)$

**Proof**

- Pick any algorithm ALG for determining bipartiteness
- For a given arbitrary graph $G=(V,E)$ represented as $n\cross n$ adj matrix A, algorithm ALG
  - Either returns TRUE
  - or Returns FALSE
- Show that ALG must have run time $\Omega(n^2)$
- Consider the behaviour of the ALG on a star graph $G_0=(V,E_0)$ with $V=\{1,2,...,n\}$ and $E_0=\{\{1,i\}:2\leq i \leq n\}$
- In each step of its computation algorithm ALG either accesses an entry in the adj matrix A or does some other computation
- Suppose that for $G_0=(V,E)$ algorithm ALG accesses exactly $L$ entries in the ADJ mat
- $L$ is the lower bound for the running time of ALG

$L=\Omega(n^2)$

For given algorithm ALG construct G1 st:

- If alg performs less than $\frac{n-1}{2}$ accesses to the adj matrix of A of G0
- G1 is not bipartite

Since G0 is bipartite, G1 is not bipartite, and ALG cannot distinguish between G0 and G1, then ALG fails

- Since $L< N\C2$ 
- There must be a pair of vertices $i,j\in V,2\leq i<j \leq n$ such that ALG neither accesses the entry A[i,j] or A[j,i]
- This means there is at least one element which wasn't queried
- ALG outputs the outcome TRUE for the sta without accessing the other entries
- ALG will output the same output for the same output TRUE for the graph
- This is a contradiction since G1 is not bipartite and hence must be different for G0 and G1
- Hence we must have $L\leq N\C2$
- Implies algorithm has time $\Omega(n^2)$

#### BFS running time

- If stored in a ADJ list, then we perform $d(v)$ for every node $v\in V$ 
- Gives asymptotically optimal running time of $O(n+m)$

- The running time is $O(n^2)$ when stored in the adjacency matrix

**Lower Bound**

- the main claim is that is impossible to acheive the $O(n+m)$ time algorithm

- showing $\Omega(n+m)$ is easier
  - Implies that for $m=\Omega(n^2)$ cannot do $o(n^2)$ time

### DFS

Recursive Formulation

![image-20220120092727670](C:\Users\leonc\AppData\Roaming\Typora\typora-user-images\image-20220120092727670.png)

- For the two versions to be equivalent the forall construct needs to consider edges in the opposite order. (First choose the edge with highest opposite end-point).

#### DFS tree

- Edges not contained in the DFS tree can only connect ancestors and descendants

**Running Time**

Same as BFS

#### Connected Components

- Run BFS or DFS from a vertex 𝑠, and remove the connected component
- Repeat until all the vertices of the graph are exhausted
- If a component 𝐶 has 𝑛𝑐 vertices and 𝑚𝑐 edges, BFS or DFS takes time $𝑂(𝑛_𝑐 + 𝑚_𝑐) $.
- In total takes $O(n+m)$ time

#### DFS Numbering

Compute in which order the recursive calls initiated by the nodes in the network finish

- Active nodes always form a path, even when vertices move into finish



### Directed Graphs

- Algorithms for BFS and DFS are the same as for undirected
- The properties of the trees are slightly different
- **BFS**
  - BFS-tree: the BFS-tree contains a shortest directed path from 𝑠 to 𝑣, for every 𝑣 ∈ 𝑉.
- **DFS**
  - All finish numbers are distinct
  - Child in the tree always has lower number
    - $\Longrightarrow$ ancestor always has a lower number 
  - If $(u,v)$ is a non-tree edge, then
    - Either $N[u]>N[v]$
    - Or $u,v$ have an ancestor/descendant relationship in the DFS forest

**Proof Of Final Statement**

Have an edge u,v - non tree edge

- $N(u)<N(v)\and u,v$ do not have an A/D relationship in the DFS forest
- Active node - already visited but have not yet finished its DFS call
- In any point in time during the DFS search, the active nodes 



The only reason that the edge $U9,v)$ is not part of the DFS tree is that v is already visited when the edge is examined

At this point in time, u has not yet finished its DFS call, therefore, v has not yet finished its DFS call as:

- $N(u)<N(v)$

This means that v is active, it is visited, but has not yet finished its DFS call

- The set of active vertices always form a path in the tree
- Since u is active, this is a contradiction to the fact that u and v do not have an ancestor/descendant relationship

#### DFs tree types of non tree edges

- Forward edge - from a node to descendant
- Backward edge - from a node to ancestor
- Cross edge - non-ancestor, descendant edges

![image-20220124131908284](C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS254.assets\image-20220124131908284.png)

#### Properties of DFS numbering

- All numbers are distinct
- If u is an ancestor of v in the DFS tree, then N[u] > N[v]

If (u,v) a non tree edge

	- Either N(u) > N(v) or
	- They have an ancestor descendant relationship in the DFS forest

![image-20220124131931535](C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS254.assets\image-20220124131931535.png)

- Always from right to left



#### Cycles in digraphs

IF G is undirected that does not contain a cycle, how many edges can G contain

- If no parallel edges, then $0\leq m\leq n-1$
- If

If no parallel edges, then its n choose 2

- A digraph with no edges is called DAG

**Definition**

Left $G=(V,E)$ be a digraph

A topological sort is a map $\phi:V\rightarrow \{1,...,n\}$

- $\forall(u,v)\in E$  $\phi(u)<\phi(v)$

**theorem**

A digraph has a topological sort iff it is a DAG

**Proof**

$\Rightarrow$

- Suppose G has a top sort,
- Assume that G has a cycle C=$(x_0,....,x_k)$
- WLOG let $x_0=$arg($min_{i\in\{1,...,k\}}\{\phi(x_i)\})$ 
- Then $(x_k,x_0)\in E$ but $\phi(x_k)\geq \phi(x_0)$

$\Leftarrow$

<img src="C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS254.assets\image-20220124133348946.png" alt="image-20220124133348946" style="zoom:50%;" />

#### DAG algorithm - topological order

Can have a tree, forward, and cross edge

- Every backward edge creates a cycle

<img src="C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS254.assets\image-20220124133742041.png" alt="image-20220124133742041" style="zoom:67%;" />

##### Checking a Digraph is a DAG

<img src="C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS254.assets\image-20220124133949486.png" alt="image-20220124133949486" style="zoom:67%;" />



#### Connected Components

- $G=(V,E)$ - undir
- Two vertices are connected, if there is a path from u to v
- Relation of connective is reflexive, symmetric and transitive - an equivalence relation
- This requivalence relation defines a partition of V into disjoint sets, called the connected componentes of G

<img src="C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS254.assets\image-20220124134236520.png" alt="image-20220124134236520" style="zoom:67%;" />

## Strongly Connected Components

- $G=(V,E)$
- Two vertices are connected if there is a path between edges in each way, once again equivalence relation
- Defines a prtition of v into disjoint sets called the strongly connected components of G

Can be considered separately 

- There is a dag betwen each Strongly Connected Component

### Finding all Strongly Connected Components

- Compute a DFS umbering for G
- Computer a graph G' obtained from G by reversing all edges
- Start a DFS in G' where the starting/restarting is alays done with the node v that has the maximum  of 𝑁 𝑣 among the yet unvisited nodes
- Trees generated in this run are strongly connected components

​	

### Write Proof Here (ABOVE THING)

### Uses of strongly connected components

- often use the decomposition of the input graph into strongly connected components jointly with topological sort, to design efficient algorithms for otherwise difficult problems
- Let G be a digraph
- Find the strongly connected components of G
- Contract each one into a single vertex



1. Find strongly connected components, then contract each
2. Topologically sort the contracted components
3. Use dynamic programming on DAGs to solve a problem



## Bi Connected Components in Undirected graphs

An undir graph G is biconnected if $G$ \\ $\{v\}$ is connected for all v

A cut vertex or articulation point is a vertex whose removal disconnects the graph

A maximal biconnected subgraph of G is a biconnected component of G

### Equivalence relation

- Connected components are strongly connected components are the equivalence classes of certain equivalence relations

let ~ be the relation on E such that e1~e2 iff e1 and e2 are contained in a simple cycle in G or e1 = e2

![image-20220131131056855](C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS254.assets\image-20220131131056855.png)

### General:

The root is an articulation point iff it has two or more children

- There are no cross edges.
- In the DFS tree:
  - Technically, the edges go in both directions, therefore, $N[u]>N[v]$, but this would also be the other way round

The leaf can never be an articulation point

**An Internal vertex point is an articulation point:**

- Iff there is a child $u$ of $v$ such that no edges connect a node from the sub tree $T_u$ rooted at $u$ to an ancestor of $v$

**Definition**

The low point of a node v in the DFS tree is the lowest level among the neighbours of nodes in the sub tree $T_v$ rooted at $v$

### Algorithm

- Compute a DFS tree
- Compute for each node its level in the DFS tree
- Compute for each node its low point
- Check for each internal node its low point
- Check for each internal node v in the DFS tree, whether the low point of one of its children is larger or equal to $v$'s level. If this is true $v$ is an articulation point, otherwise not
- Incorporated into one DFS cycle

<img src="C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS254.assets\image-20220131132648252.png" alt="image-20220131132648252" style="zoom: 33%;" />

#### Viewpoint of a Single node

In DFS call, we're in node x in level l

1. Call DFA to all unvisited neighbours y of x
   - Edge $\set{x,y}$ becomes a DFS tree edge
   - Level of y is equal to l + 1
2. Invariant: we already know the low point of all descendants of x
3. Compute low-point of 𝑥 (initially low-point(𝑥) = level of 𝑥)
   - For every edge  $\set{x,y}\in E$
     - If x is a descendant of y, then update low point of x
       - Low point x = min$\set{lowPoint(x), level(y)}$
     - If x is the parent of y the update low point x
       - Low point x = min$\set{lowPoint(x), lowPoint(y)}$
     - If x is the parent of y, then check if x is an articulation point
       - If $lowPooint(y)\leq level(x)$ then mark x as an articulation point

#### Running Time

Runs in $O(n+m)$ - in one run of DFS

- Can be extended to find all biconnected components in $O(n+m)$ time



## Bipartiteness in DFS

![image-20220131134101523](C:\Users\leonc\Documents\Warwick\CSY2\modulenotes\CS254.assets\image-20220131134101523.png)

The level set $L_i$ contains nodes at distance $i$ from the root

- G is bipartite iff each connected component of G is bipartite
- Connected G is bipartite iff every cycle in G is even
- If $\set{u,v}\in E$ with u,v both on odd level $\rightarrow$ consider cycle from $u$ to their least common ancestor $z$ then from $z$ to v and then $\set {u,v}$ 



**If G has no edge, containing two vertices on odd or on even, then G is bipartite**

Create a bi colouring of the graph, 

- V0 vertices on even levels
- V1 vertices on odd levels

### Any Graph Exploration can be used for bipartiteness

- Any graph exporation generates a spanning tree T 































